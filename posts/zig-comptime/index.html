<!DOCTYPE html>
<html lang="es" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Zig comptime | Zig-zagueando Blog</title>
<meta name="keywords" content="Zig, Compilación condicional, Comptime, Bucle inline for, Metaprogramación, Asignación de memoria, Tipos de retorno, Optimización de código, Lenguaje de programación, Desarrollo de software, Eficiencia del código, Rendimiento del código, Depuración, Variables en tiempo de compilación, Control de flujo en tiempo de compilación, Errores en tiempo de compilación, Metaprogramación en Zig, Programación genérica, Ramificaciones de código, Desarrollo ágil, Mejores prácticas de programación, Herramientas de programación, Flexibilidad del código, Seguridad del código, Limpieza del código, Compilación optimizada, Implementación eficiente, Tipos de datos en Zig, Declaración de variables, Uso de punteros en Zig, Optimización del rendimiento, Manipulación de matrices, Aumento de la productividad, Experiencia de desarrollo fluida, Depuración en tiempo de compilación, Asertos en tiempo de compilación, Compatibilidad con otros lenguajes, Mantenimiento del código, Mejora continua del software, Código confiable, Desempeño del programa, Documentación de código, Metodologías de desarrollo, Aprendizaje continuo, Programación eficiente, Errores en tiempo de ejecución, Preparación previa a la ejecución, Optimización de algoritmos, Pruebas de software, Programación sin errores, Compilación eficiente, Desarrollo de código limpio, Buenas prácticas de codificación, Código más robusto, Herramientas de optimización, Compilación y rendimiento, Programación de bajo nivel, Eficiencia de recursos, Mejora de la productividad del desarrollo, Código de alta calidad, Codificación sin errores, Programación orientada a objetos, Desarrollo de aplicaciones, Programación estructurada">
<meta name="description" content="¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮
¿Qué es comptime? El término comptime viene de &ldquo;Compile Time&rdquo; que, traducido al español, sería &ldquo;Tiempo de Compilación&rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante.">
<meta name="author" content="d4c7">
<link rel="canonical" href="https://d4c7.github.io/zig-zagueando/posts/zig-comptime/">
<link crossorigin="anonymous" href="/zig-zagueando/assets/css/stylesheet.8e8af8c7897af6457d28b7ea77a4d4acf670934d081625a7b0ec0a87f8fcbfcf.css" integrity="sha256-jor4x4l69kV9KLfqd6TUrPZwk00IFiWnsOwKh/j8v88=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/zig-zagueando/assets/js/highlight.9a8019f45628f095e5668671b3b0e124b8cf7dda465f36166dcc239c8748a257.js" integrity="sha256-moAZ9FYo8JXlZoZxs7DhJLjPfdpGXzYWbcwjnIdIolc="
    onload="hljs.configure({ignoreUnescapedHTML:true});hljs.highlightAll();"></script>
<link rel="icon" href="https://d4c7.github.io/zig-zagueando/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://d4c7.github.io/zig-zagueando/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://d4c7.github.io/zig-zagueando/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://d4c7.github.io/zig-zagueando/apple-touch-icon.png">
<link rel="mask-icon" href="https://d4c7.github.io/zig-zagueando/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<noscript>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@300&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@600&family=Tajawal:wght@300&display=swap" rel="stylesheet">
</noscript>

<link rel="preload" href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@600&family=Tajawal:wght@300&display=swapp" as="style" onload="this.onload=null;this.rel='stylesheet'">



<script async src="https://www.googletagmanager.com/gtag/js?id=G-59LR4NE7W9"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-59LR4NE7W9', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Zig comptime" />
<meta property="og:description" content="¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮
¿Qué es comptime? El término comptime viene de &ldquo;Compile Time&rdquo; que, traducido al español, sería &ldquo;Tiempo de Compilación&rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://d4c7.github.io/zig-zagueando/posts/zig-comptime/" />
<meta property="og:image" content="https://d4c7.github.io/zig-zagueando/covers/zig-comptime.webp" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-18T00:00:00+00:00" /><meta property="og:site_name" content="Programando con Zig" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://d4c7.github.io/zig-zagueando/covers/zig-comptime.webp" />
<meta name="twitter:title" content="Zig comptime"/>
<meta name="twitter:description" content="¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮
¿Qué es comptime? El término comptime viene de &ldquo;Compile Time&rdquo; que, traducido al español, sería &ldquo;Tiempo de Compilación&rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://d4c7.github.io/zig-zagueando/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Zig comptime",
      "item": "https://d4c7.github.io/zig-zagueando/posts/zig-comptime/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Zig comptime",
  "name": "Zig comptime",
  "description": "¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮\n¿Qué es comptime? El término comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al español, sería \u0026ldquo;Tiempo de Compilación\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante.",
  "keywords": [
    "Zig", "Compilación condicional", "Comptime", "Bucle inline for", "Metaprogramación", "Asignación de memoria", "Tipos de retorno", "Optimización de código", "Lenguaje de programación", "Desarrollo de software", "Eficiencia del código", "Rendimiento del código", "Depuración", "Variables en tiempo de compilación", "Control de flujo en tiempo de compilación", "Errores en tiempo de compilación", "Metaprogramación en Zig", "Programación genérica", "Ramificaciones de código", "Desarrollo ágil", "Mejores prácticas de programación", "Herramientas de programación", "Flexibilidad del código", "Seguridad del código", "Limpieza del código", "Compilación optimizada", "Implementación eficiente", "Tipos de datos en Zig", "Declaración de variables", "Uso de punteros en Zig", "Optimización del rendimiento", "Manipulación de matrices", "Aumento de la productividad", "Experiencia de desarrollo fluida", "Depuración en tiempo de compilación", "Asertos en tiempo de compilación", "Compatibilidad con otros lenguajes", "Mantenimiento del código", "Mejora continua del software", "Código confiable", "Desempeño del programa", "Documentación de código", "Metodologías de desarrollo", "Aprendizaje continuo", "Programación eficiente", "Errores en tiempo de ejecución", "Preparación previa a la ejecución", "Optimización de algoritmos", "Pruebas de software", "Programación sin errores", "Compilación eficiente", "Desarrollo de código limpio", "Buenas prácticas de codificación", "Código más robusto", "Herramientas de optimización", "Compilación y rendimiento", "Programación de bajo nivel", "Eficiencia de recursos", "Mejora de la productividad del desarrollo", "Código de alta calidad", "Codificación sin errores", "Programación orientada a objetos", "Desarrollo de aplicaciones", "Programación estructurada"
  ],
  "articleBody": "¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮\n¿Qué es comptime? El término comptime viene de “Compile Time” que, traducido al español, sería “Tiempo de Compilación”. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante. En Zig, puedes decidir qué parte de tu código se ejecutará en tiempo de compilación y cuál en tiempo de ejecución. 🕓\nPrincipales ventajas de comptime Quizás te estés preguntando, ¿por qué querríamos hacer cálculos en tiempo de compilación?\nFlexibilidad: Gracias a comptime, puedes generar código en tiempo de compilación de forma dinámica. Esto significa que puedes decidir cómo se comportará tu programa en función de las condiciones existentes durante la compilación. 😏\nEficiencia: Al mover ciertas operaciones al tiempo de compilación, puedes mejorar significativamente la eficiencia de tu código en tiempo de ejecución. En lugar de calcular algo cada vez que se ejecuta tu programa, lo calculas una vez durante la compilación y ya está. Es como preparar toda la comida de antemano para que, cuando lleguen los invitados, ¡solo tengas que encender el fuego! 🍳⏲️\nSeguridad: comptime puede ayudarte a detectar errores en tiempo de compilación en lugar de en tiempo de ejecución. Cuanto antes detectes los errores, más segura será tu aplicación. 💪\nAbstracción sin costo: A diferencia de otros lenguajes que pagan un precio por abstracciones de alto nivel (con rendimiento más lento o más memoria usada), Zig permite abstracciones sin costos adicionales, gracias al poder de comptime.🎉\nEjemplo básico de uso de comptime En su forma más básica comptime es la forma en la que una variable se calcula en tiempo de compilación para convertirse en una constante en tiempo de ejecución. Aquí hay un pequeño fragmento de código para que te hagas una idea de cómo se utiliza comptime.\n⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\nfn suma() u64 { var r: u64 = 0; for (1..100) |i| { r += i; } return r; } pub fn main() void { var s = comptime suma(); std.debug.print(\"{}\", .{s}); sumaB(); } Cuando compiles este código, verás que suma se calcula en tiempo de compilación y su resultado es simplemente una constante. En tiempo de ejecución, este bloque comptime no tiene ningún efecto.\nexample.main: push rbp mov rbp, rsp sub rsp, 16 mov qword ptr [rbp - 8], 4950 call debug.print__anon_3471 add rsp, 16 pop rbp ret Explicación del código Este código es esamblador de arquitectura x86-64 (o AMD64):\npush rbp: Guarda el valor actual del puntero base del marco (frame base pointer) en la pila. Esto se hace generalmente al inicio de una función para preservar el valor actual de rbp para poder restaurarlo más tarde.\nmov rbp, rsp: Establece el puntero base del marco al valor actual del puntero de la pila (stack pointer). Esto se hace para que la función tenga un punto de referencia fijo para acceder a las variables locales y los argumentos.\nsub rsp, 16: Reserva 16 bytes en la pila para las variables locales de esta función, moviendo el puntero de la pila hacia abajo (en la mayoría de las arquitecturas, la pila crece hacia abajo en la memoria).\nmov qword ptr [rbp - 8], 4950: Guarda el valor 4950 en la ubicación de la pila 8 bytes por debajo del puntero base del marco. Probablemente esto está inicializando una variable local.\ncall debug.print__anon_3471: Llama a la función debug.print__anon_3471. Esta función pinta el valor de la variable local que acabamos de inicializar.\nadd rsp, 16: Restablece el puntero de la pila a su posición antes de que reserváramos espacio para las variables locales. Esto efectivamente “libera” ese espacio de la pila.\npop rbp: Restaura el puntero base del marco a su valor antes de la llamada a la función, esencialmente limpiando después de que la función haya terminado.\nret: Retorna de la función, saltando de vuelta a la dirección de retorno almacenada en la pila por la instrucción call que llamó a esta función.\nOtra forma de asignar un cáculo en comptime a una variable o constate es usando break :equita valor en un bloque:\nvar s = comptime e: { var r: u64 = 0; for (1..100) |i| { r += i; } break :e r; }; ¿Pero que pasaría si nos encontramos un bucle demasiado largo en tiempo de compilación? Comptime tiene un limitador de la cantidad de ramificaciones que se pueden evaluar en tiempo de compilación, lo cual es útil para prevenir bucles infinitos y otros problemas que pueden consumir una cantidad excesiva de recursos durante la compilación. Se puede cambiar el límite con la función @setEvalBranchQuota(), que por defecto es 1000.\nCombiene recordarlo si nos encontramos con un error similar a este compilando:\nerror: evaluation exceeded 1000 backwards branches note: use @setEvalBranchQuota() to raise the branch limit from 1000 Comparación con tiempo de ejecución Entonces, ¿cómo se compara comptime con los cálculos en tiempo de ejecución tradicionales? Cuando un programa Zig se está ejecutando, a menudo hay decisiones que tomar, como elegir qué ramas de código ejecutar. Normalmente, esto ocurre en tiempo de ejecución, pero con comptime, estas decisiones se pueden tomar en tiempo de compilación. Es como resolver la mayor parte del rompecabezas antes de que empiece a correr el reloj. ⏳🧩\nAplicaciones prácticas de comptime De acuerdo, la teoría es buena, ¡pero veamos comptime en acción! Te guiaré a través de algunos ejemplos prácticos donde comptime puede brillar, como cuando trabajas con metaprogramación o programación genérica. ¡Aquí es donde comptime pasa de ser simplemente ‘genial’ a ‘absolutamente fantástico’! 🌟🔧\nQué es @compileLog En Zig, @compileLog es una función incorporada que te permite registrar mensajes durante el tiempo de compilación. Es una herramienta maravillosa para la depuración o para entender lo que está sucediendo en tiempo de compilación. Aquí tienes un ejemplo rápido:\ncomptime { const a = 5; @compileLog(\"Valor de a en tiempo de compilación: \", a); } En el código anterior, @compileLog imprimirá el mensaje “Valor de a en tiempo de compilación: 5” durante el proceso de compilación. ¡Esto puede ser muy útil cuando estás lidiando con expresiones o funciones comptime complejas! 🤔💭\nHay que hace notar que, a día de hoy, la compilación fallará si se ha ejecutado cualquier @compileLog. La razón es evitar que las librerías polucionen de mensajes la compilación de un programa.\nQué es @compileError @compileError es otra función incorporada en Zig que se utiliza para lanzar un error en tiempo de compilación. Esto es súper útil para asegurar ciertas condiciones durante el tiempo de compilación y detener la compilación si no se cumplen. Así es cómo puedes usarlo:\ncomptime { if (!std.builtin.target.isWasm()) { @compileError(\"WasmPageAllocator is only available for wasm32 arch\"); } } En este ejemplo, si la arquitectura en la se está intentando compilar el programa no es la adecuada se lanzará un error de compilación con @compileError 💥🛑\nComptime para metaprogramación La metaprogramación se refiere a la capacidad de un programa para tratar su código como datos y manipularlo. En Zig, comptime proporciona una forma poderosa de lograr la metaprogramación. Por ejemplo, puedes generar funciones especializadas para diferentes tipos:\nfn createAdder(comptime T: type) type { return struct { fn add(a: T, b: T) T { return a + b; } }; } const IntAdder = createAdder(i32); const FloatAdder = createAdder(f32); var i = IntAdder.add(10, 20); var f = FloatAdder.add(1.0, 2.0); En el código anterior, estamos generando dos estructuras en tiempo de compilación: IntAdder y FloatAdder. Cada una tiene una función add, pero trabajan con tipos diferentes (i32 y f32). ¡Esto es solo la punta del iceberg cuando se trata de metaprogramación con comptime! 🧠🔮\nPor ejemplo, podemos crear estructuras completas en tiempo de compilación:\nfn makeType(comptime n: usize) type { var fields: [n]std.builtin.Type.StructField = undefined; inline for (0..n) |v| { const default_value: u32 = v; fields[v] = .{ .name = std.fmt.comptimePrint(\"field{}\", .{v}), .type = @TypeOf(default_value), .default_value = @ptrCast(*const anyopaque, \u0026default_value), .is_comptime = false, .alignment = @alignOf(@TypeOf(default_value)), }; } return @Type(.{ .Struct = .{ .layout = .Auto, .fields = fields[0..], .decls = \u0026.{}, .is_tuple = false, } }); } const T2 = comptime makeType(2); std.debug.print(\"{any}\\n\", .{T2{}}); const T3 = comptime makeType(3); std.debug.print(\"{any}\\n\", .{T3{}}); sample.makeType(2){ .field0 = 0, .field1 = 1 } sample.makeType(3){ .field0 = 0, .field1 = 1, .field2 = 2 } Detalles importantes en este código:\nLa matriz fields tiene un tamaño fijo determinado en tiempo de compilación.\nEl bucle inline for itera sobre el rango 0..n. Es por tanto un bucle que se desenrrolla. ¿Crees que es obligatorio este desenrollado? ¿En necesario?\nComptime y asignación de memoria Lo ideal sería poder utilizar todas las estructuras de datos disponibles en Zig para poder ejectuar cálculos en tiempo de compilación. Aunque de momento no existe en la librería estándar un asignador de memoria (allocator) de Zig en para tiempo de compilación, podemos implementar el nuestro propio con facilidad. Así, con un poco de cuaidado, podremos usar en comptime, de forma auxilia,r estructuras como std.ArrayList:\nfn makeSlice(allocator: std.mem.Allocator) ![]u8 { var list = std.ArrayList(u8).init(allocator); defer list.deinit(); try list.append(1); try list.append(2); return try list.toOwnedSlice(); } const array = comptime e: { var buffer: [1024]u8 = undefined; var cfba = ComptimeFixedBufferAllocator.init(\u0026buffer); const v = makeSlice(cfba.allocator()) catch { @compileError(\"allocation error, increase fixed buffer size\"); }; break :e v[0..].*; }; std.debug.print(\"{any}\\n\", .{array}); ⚠️ *¡Atención, programador! Ten en cuenta que siempre debes transformar los slices en matrices constantes para evitar incrustar todo el buffer de memoria del allocator en el programa compilado final, fíjate en break :e v[0..].*;. Esto es importante.\nVer código de ejemplo de un allocator para comptime Es básicamente una copia de std.heap.FixedBufferAllocator. Por cierto, ¿por qué crees que no podemos usarlo en comptime?:\npub const ComptimeFixedBufferAllocator = struct { end_index: usize, buffer: []u8, pub fn init(buffer: []u8) ComptimeFixedBufferAllocator { return ComptimeFixedBufferAllocator{ .buffer = buffer, .end_index = 0, }; } pub fn allocator(self: *ComptimeFixedBufferAllocator) std.mem.Allocator { return .{ .ptr = self, .vtable = \u0026.{ .alloc = alloc, .resize = resize, .free = free, }, }; } pub fn isLastAllocation(self: *ComptimeFixedBufferAllocator, buf: []u8) bool { return buf.ptr + buf.len == self.buffer.ptr + self.end_index; } fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = ra; const ptr_align = @as(usize, 1) \u003c\u003c @intCast(std.mem.Allocator.Log2Align, log2_ptr_align); const adjust_off = std.mem.alignPointerOffset(self.buffer.ptr + self.end_index, ptr_align) orelse return null; const adjusted_index = self.end_index + adjust_off; const new_end_index = adjusted_index + n; if (new_end_index \u003e self.buffer.len) return null; self.end_index = new_end_index; return self.buffer.ptr + adjusted_index; } fn resize( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, new_size: usize, return_address: usize, ) bool { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (!self.isLastAllocation(buf)) { if (new_size \u003e buf.len) return false; return true; } if (new_size \u003c= buf.len) { const sub = buf.len - new_size; self.end_index -= sub; return true; } const add = new_size - buf.len; if (add + self.end_index \u003e self.buffer.len) return false; self.end_index += add; return true; } fn free( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, return_address: usize, ) void { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (self.isLastAllocation(buf)) { self.end_index -= buf.len; } } pub fn reset(self: *ComptimeFixedBufferAllocator) void { self.end_index = 0; } }; Recuerda que aunque comptime nos permite realizar algunos trucos poderosos, no es una solución milagrosa. Es simplemente otra herramienta en nuestro kit de herramientas Zig que, cuando se usa adecuadamente, puede conducir a un código más limpio, eficiente y robusto. ¡Pero como siempre, con un gran poder viene una gran responsabilidad! Así que usemos comptime sabiamente…\nLimitaciones de comptime ️🕸️ Hay algunos posibles problemas al usar comptime de los que debes estar al tanto 😅. Los principales son:\nSin operaciones de I/O: Durante el tiempo de compilación, no puedes realizar ninguna operación de entrada/salida. Así es, no puedes leer archivos, escribir en la consola, comunicarte a través de la red, ¡nada! Recuerda, comptime opera en una máquina abstracta idealizada sin acceso al mundo exterior. 🌐🔒\nSin acceso a variables de entorno: De manera similar, comptime no tiene acceso a las variables de entorno en tiempo de ejecución. Esto incluye cosas como la hora del sistema, el identificador del proceso o las variables de entorno específicas del usuario. ¡Todo se trata del código, amigos! 🖥️🚫\nAsignación de memoria: Hablamos antes de cómo comptime gestiona la memoria y la falta de un allocator para comptime. Es importante recordar que comptime y el tiempo de ejecución son dos dominios diferentes. 🧙‍♂️🏰\n¡Y ya está, amigos!. Un profundo viaje al mundo mágico de comptime en Zig. Espero que hayas disfrutado nuestro recorrido y que ahora estés tan entusiasmado con comptime como yo. Recuerda, el aprendizaje es un proceso continuo, así que nunca dejes de explorar y experimentar con Zig. ¡Sigue codificando con pasión y creatividad! 🚀💻\n",
  "wordCount" : "2150",
  "inLanguage": "es",
  "image":"https://d4c7.github.io/zig-zagueando/covers/zig-comptime.webp","datePublished": "2023-06-18T00:00:00Z",
  "dateModified": "2023-06-18T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "d4c7"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://d4c7.github.io/zig-zagueando/posts/zig-comptime/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Zig-zagueando Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://d4c7.github.io/zig-zagueando/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://d4c7.github.io/zig-zagueando/" accesskey="h" title="Zig-zagueando Blog (Alt + H)">Zig-zagueando Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://d4c7.github.io/zig-zagueando/search/" title="Buscar">
                    <span>Buscar</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://d4c7.github.io/zig-zagueando/">Inicio</a>&nbsp;»&nbsp;<a href="https://d4c7.github.io/zig-zagueando/posts/">Posts</a></div>
    <h1 class="post-title">
      Zig comptime
    </h1>
    <div class="post-meta"><span title='2023-06-18 00:00:00 +0000 +0000'>junio 18, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2150 palabras&nbsp;·&nbsp;d4c7

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://d4c7.github.io/zig-zagueando/covers/zig-comptime.webp" alt="">
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Tabla de Contenidos</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#qué-es-comptime">¿Qué es comptime?</a></li>
    <li><a href="#principales-ventajas-de-comptime">Principales ventajas de comptime</a></li>
    <li><a href="#ejemplo-básico-de-uso-de-comptime">Ejemplo básico de uso de comptime</a></li>
    <li><a href="#comparación-con-tiempo-de-ejecución">Comparación con tiempo de ejecución</a></li>
    <li><a href="#aplicaciones-prácticas-de-comptime">Aplicaciones prácticas de comptime</a></li>
    <li><a href="#qué-es-compilelog">Qué es @compileLog</a></li>
    <li><a href="#qué-es-compileerror">Qué es @compileError</a></li>
    <li><a href="#comptime-para-metaprogramación">Comptime para metaprogramación</a></li>
    <li><a href="#comptime-y-asignación-de-memoria">Comptime y asignación de memoria</a></li>
    <li><a href="#limitaciones-de-comptime">Limitaciones de comptime</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el <code>comptime</code>! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮</p>
<h2 id="qué-es-comptime">¿Qué es comptime?<a hidden class="anchor" aria-hidden="true" href="#qué-es-comptime">#</a></h2>
<p>El término <code>comptime</code> viene de &ldquo;Compile Time&rdquo; que, traducido al español, sería &ldquo;Tiempo de Compilación&rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante. En Zig, puedes decidir qué parte de tu código se ejecutará en tiempo de compilación y cuál en tiempo de ejecución. 🕓</p>
<h2 id="principales-ventajas-de-comptime">Principales ventajas de comptime<a hidden class="anchor" aria-hidden="true" href="#principales-ventajas-de-comptime">#</a></h2>
<p>Quizás te estés preguntando, ¿por qué querríamos hacer cálculos en tiempo de compilación?</p>
<ol>
<li>
<p>Flexibilidad: Gracias a <code>comptime</code>, puedes generar código en tiempo de compilación de forma dinámica. Esto significa que puedes decidir cómo se comportará tu programa en función de las condiciones existentes durante la compilación. 😏</p>
</li>
<li>
<p>Eficiencia: Al mover ciertas operaciones al tiempo de compilación, puedes mejorar significativamente la eficiencia de tu código en tiempo de ejecución. En lugar de calcular algo cada vez que se ejecuta tu programa, lo calculas una vez durante la compilación y ya está. Es como preparar toda la comida de antemano para que, cuando lleguen los invitados, ¡solo tengas que encender el fuego! 🍳⏲️</p>
</li>
<li>
<p>Seguridad: <code>comptime</code> puede ayudarte a detectar errores en tiempo de compilación en lugar de en tiempo de ejecución. Cuanto antes detectes los errores, más segura será tu aplicación. 💪</p>
</li>
<li>
<p>Abstracción sin costo: A diferencia de otros lenguajes que pagan un precio por abstracciones de alto nivel (con rendimiento más lento o más memoria usada), Zig permite abstracciones sin costos adicionales, gracias al poder de <code>comptime</code>.🎉</p>
</li>
</ol>
<h2 id="ejemplo-básico-de-uso-de-comptime">Ejemplo básico de uso de comptime<a hidden class="anchor" aria-hidden="true" href="#ejemplo-básico-de-uso-de-comptime">#</a></h2>
<p>En su forma más básica <code>comptime</code> es la forma en la que una variable se calcula en tiempo de compilación para convertirse en una constante en tiempo de ejecución. Aquí hay un pequeño fragmento de código para que te hagas una idea de cómo se utiliza <code>comptime</code>.</p>
<blockquote>
<p>⚠️ <em>¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>suma()<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">u64</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>r<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">u64</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">0</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">for</span><span style="color:#bbb"> </span>(<span style="color:#099">1</span>..<span style="color:#099">100</span>)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">|</span>i<span style="color:#000;font-weight:bold">|</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>r<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+=</span><span style="color:#bbb"> </span>i;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>r;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>main()<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">void</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>s<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>suma();<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>std.debug.print(<span style="color:#d14">&#34;{}&#34;</span>,<span style="color:#bbb"> </span>.{s});<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>sumaB();<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>Cuando compiles este código, verás que <code>suma</code> se calcula en tiempo de compilación y su resultado es simplemente una constante. En tiempo de ejecución, este bloque <code>comptime</code> no tiene ningún efecto.</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">example.main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     qword ptr [rbp - 8], 4950
        call    debug.print__anon_3471
        add     rsp, 16
        pop     rbp
        ret
</code></pre><details>
    <summary>Explicación del código</summary>
    <div class="inner-summary">
    <p>Este código es esamblador de arquitectura x86-64 (o AMD64):</p>
<ol>
<li>
<p><strong>push rbp</strong>: Guarda el valor actual del puntero base del marco (frame base pointer) en la pila. Esto se hace generalmente al inicio de una función para preservar el valor actual de rbp para poder restaurarlo más tarde.</p>
</li>
<li>
<p><strong>mov rbp, rsp</strong>: Establece el puntero base del marco al valor actual del puntero de la pila (stack pointer). Esto se hace para que la función tenga un punto de referencia fijo para acceder a las variables locales y los argumentos.</p>
</li>
<li>
<p><strong>sub rsp, 16</strong>: Reserva 16 bytes en la pila para las variables locales de esta función, moviendo el puntero de la pila hacia abajo (en la mayoría de las arquitecturas, la pila crece hacia abajo en la memoria).</p>
</li>
<li>
<p><strong>mov qword ptr [rbp - 8], 4950</strong>: Guarda el valor 4950 en la ubicación de la pila 8 bytes por debajo del puntero base del marco. Probablemente esto está inicializando una variable local.</p>
</li>
<li>
<p><strong>call debug.print__anon_3471</strong>: Llama a la función <code>debug.print__anon_3471</code>. Esta función pinta el valor de la variable local que acabamos de inicializar.</p>
</li>
<li>
<p><strong>add rsp, 16</strong>: Restablece el puntero de la pila a su posición antes de que reserváramos espacio para las variables locales. Esto efectivamente &ldquo;libera&rdquo; ese espacio de la pila.</p>
</li>
<li>
<p><strong>pop rbp</strong>: Restaura el puntero base del marco a su valor antes de la llamada a la función, esencialmente limpiando después de que la función haya terminado.</p>
</li>
<li>
<p><strong>ret</strong>: Retorna de la función, saltando de vuelta a la dirección de retorno almacenada en la pila por la instrucción <code>call</code> que llamó a esta función.</p>
</li>
</ol>

    </div>
</details>

<p>Otra forma de asignar un cáculo en <code>comptime</code> a una variable o constate es usando <code>break :equita valor</code> en un bloque:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>s<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>e<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>r<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">u64</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">0</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">for</span><span style="color:#bbb"> </span>(<span style="color:#099">1</span>..<span style="color:#099">100</span>)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">|</span>i<span style="color:#000;font-weight:bold">|</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>r<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+=</span><span style="color:#bbb"> </span>i;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">break</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">:</span>e<span style="color:#bbb"> </span>r;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>};<span style="color:#bbb">
</span></span></span></code></pre></div><p>¿Pero que pasaría si nos encontramos un bucle demasiado largo en tiempo de compilación? Comptime tiene un limitador de la cantidad de ramificaciones que se pueden evaluar en tiempo de compilación, lo cual es útil para prevenir bucles infinitos y otros problemas que pueden consumir una cantidad excesiva de recursos durante la compilación. Se puede cambiar el límite con la función <code>@setEvalBranchQuota()</code>, que por defecto es <code>1000</code>.</p>
<p>Combiene recordarlo si nos encontramos con un error similar a este compilando:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>error: evaluation exceeded 1000 backwards branches
</span></span><span style="display:flex;"><span>note: use @setEvalBranchQuota() to raise the branch limit from 1000
</span></span></code></pre></div><h2 id="comparación-con-tiempo-de-ejecución">Comparación con tiempo de ejecución<a hidden class="anchor" aria-hidden="true" href="#comparación-con-tiempo-de-ejecución">#</a></h2>
<p>Entonces, ¿cómo se compara <code>comptime</code> con los cálculos en tiempo de ejecución tradicionales? Cuando un programa Zig se está ejecutando, a menudo hay decisiones que tomar, como elegir qué ramas de código ejecutar. Normalmente, esto ocurre en tiempo de ejecución, pero con <code>comptime</code>, estas decisiones se pueden tomar en tiempo de compilación. Es como resolver la mayor parte del rompecabezas antes de que empiece a correr el reloj. ⏳🧩</p>
<h2 id="aplicaciones-prácticas-de-comptime">Aplicaciones prácticas de comptime<a hidden class="anchor" aria-hidden="true" href="#aplicaciones-prácticas-de-comptime">#</a></h2>
<p>De acuerdo, la teoría es buena, ¡pero veamos <code>comptime</code> en acción! Te guiaré a través de algunos ejemplos prácticos donde <code>comptime</code> puede brillar, como cuando trabajas con metaprogramación o programación genérica. ¡Aquí es donde <code>comptime</code> pasa de ser simplemente &lsquo;genial&rsquo; a &lsquo;absolutamente fantástico&rsquo;! 🌟🔧</p>
<h2 id="qué-es-compilelog">Qué es @compileLog<a hidden class="anchor" aria-hidden="true" href="#qué-es-compilelog">#</a></h2>
<p>En Zig, <code>@compileLog</code> es una función incorporada que te permite registrar mensajes durante el tiempo de compilación. Es una herramienta maravillosa para la depuración o para entender lo que está sucediendo en tiempo de compilación. Aquí tienes un ejemplo rápido:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>a<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">5</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#0086b3">@compileLog</span>(<span style="color:#d14">&#34;Valor de a en tiempo de compilación: &#34;</span>,<span style="color:#bbb"> </span>a);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>En el código anterior, <code>@compileLog</code> imprimirá el mensaje &ldquo;Valor de a en tiempo de compilación: 5&rdquo; durante el proceso de compilación. ¡Esto puede ser muy útil cuando estás lidiando con expresiones o funciones <code>comptime</code> complejas! 🤔💭</p>
<p>Hay que hace notar que, a día de hoy, la compilación fallará si se ha ejecutado cualquier <code>@compileLog</code>. La razón es evitar que las librerías polucionen de mensajes la compilación de un programa.</p>
<h2 id="qué-es-compileerror">Qué es @compileError<a hidden class="anchor" aria-hidden="true" href="#qué-es-compileerror">#</a></h2>
<p><code>@compileError</code> es otra función incorporada en Zig que se utiliza para lanzar un error en tiempo de compilación. Esto es súper útil para asegurar ciertas condiciones durante el tiempo de compilación y detener la compilación si no se cumplen. Así es cómo puedes usarlo:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>(<span style="color:#000;font-weight:bold">!</span>std.builtin.target.isWasm())<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#0086b3">@compileError</span>(<span style="color:#d14">&#34;WasmPageAllocator is only available for wasm32 arch&#34;</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>En este ejemplo, si la arquitectura en la se está intentando compilar el programa no es la adecuada se lanzará un error de compilación con <code>@compileError</code> 💥🛑</p>
<h2 id="comptime-para-metaprogramación">Comptime para metaprogramación<a hidden class="anchor" aria-hidden="true" href="#comptime-para-metaprogramación">#</a></h2>
<p>La metaprogramación se refiere a la capacidad de un programa para tratar su código como datos y manipularlo. En Zig, <code>comptime</code> proporciona una forma poderosa de lograr la metaprogramación. Por ejemplo, puedes generar funciones especializadas para diferentes tipos:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>createAdder(<span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>T<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">type</span>)<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">type</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">struct</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>add(a<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>T,<span style="color:#bbb"> </span>b<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>T)<span style="color:#bbb"> </span>T<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>a<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>b;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>};<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>IntAdder<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>createAdder(<span style="color:#458;font-weight:bold">i32</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>FloatAdder<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>createAdder(<span style="color:#458;font-weight:bold">f32</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>i<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>IntAdder.add(<span style="color:#099">10</span>,<span style="color:#bbb"> </span><span style="color:#099">20</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>f<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>FloatAdder.add(<span style="color:#099">1.0</span>,<span style="color:#bbb"> </span><span style="color:#099">2.0</span>);<span style="color:#bbb">
</span></span></span></code></pre></div><p>En el código anterior, estamos generando dos estructuras en tiempo de compilación: <code>IntAdder</code> y <code>FloatAdder</code>. Cada una tiene una función <code>add</code>, pero trabajan con tipos diferentes (<code>i32</code> y <code>f32</code>). ¡Esto es solo la punta del iceberg cuando se trata de metaprogramación con <code>comptime</code>! 🧠🔮</p>
<p>Por ejemplo, podemos crear estructuras completas en tiempo de compilación:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>makeType(<span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>n<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">usize</span>)<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">type</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>fields<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>[n]std.builtin.Type.StructField<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">undefined</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">inline</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">for</span><span style="color:#bbb"> </span>(<span style="color:#099">0</span>..n)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">|</span>v<span style="color:#000;font-weight:bold">|</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>default_value<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">u32</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>v;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>fields[v]<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>.{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.name<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>std.fmt.comptimePrint(<span style="color:#d14">&#34;field{}&#34;</span>,<span style="color:#bbb"> </span>.{v}),<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.<span style="color:#458;font-weight:bold">type</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#0086b3">@TypeOf</span>(default_value),<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.default_value<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#0086b3">@ptrCast</span>(<span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>anyopaque,<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&amp;</span>default_value),<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.is_comptime<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">false</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.alignment<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#0086b3">@alignOf</span>(<span style="color:#0086b3">@TypeOf</span>(default_value)),<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>};<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#0086b3">@Type</span>(.{<span style="color:#bbb"> </span>.Struct<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>.{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>.layout<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>.Auto,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>.fields<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>fields[<span style="color:#099">0</span>..],<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>.decls<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&amp;</span>.{},<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>.is_tuple<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">false</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb"> </span>});<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>T2<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>makeType(<span style="color:#099">2</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>std.debug.print(<span style="color:#d14">&#34;{any}</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,<span style="color:#bbb"> </span>.{T2{}});<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>T3<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>makeType(<span style="color:#099">3</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>std.debug.print(<span style="color:#d14">&#34;{any}</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,<span style="color:#bbb"> </span>.{T3{}});<span style="color:#bbb">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>sample.makeType(2){ .field0 = 0, .field1 = 1 }
</span></span><span style="display:flex;"><span>sample.makeType(3){ .field0 = 0, .field1 = 1, .field2 = 2 }
</span></span></code></pre></div><p>Detalles importantes en este código:</p>
<ol>
<li>
<p>La matriz <code>fields</code> tiene un tamaño fijo determinado en tiempo de compilación.</p>
</li>
<li>
<p>El bucle <code>inline for</code> itera sobre el rango <code>0..n</code>. Es por tanto un bucle que se desenrrolla. ¿Crees que es obligatorio este desenrollado? ¿En necesario?</p>
</li>
</ol>
<h2 id="comptime-y-asignación-de-memoria">Comptime y asignación de memoria<a hidden class="anchor" aria-hidden="true" href="#comptime-y-asignación-de-memoria">#</a></h2>
<p>Lo ideal sería poder utilizar todas las estructuras de datos disponibles en Zig para poder ejectuar cálculos en tiempo de compilación. Aunque de momento no existe en la librería estándar un asignador de memoria (allocator) de Zig en para tiempo de compilación, podemos implementar el nuestro propio con facilidad. Así, con un poco de cuaidado, podremos usar en comptime, de forma auxilia,r estructuras como <code>std.ArrayList</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>makeSlice(allocator<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>std.mem.Allocator)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">!</span>[]<span style="color:#458;font-weight:bold">u8</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>list<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>std.ArrayList(<span style="color:#458;font-weight:bold">u8</span>).init(allocator);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">defer</span><span style="color:#bbb"> </span>list.deinit();<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">try</span><span style="color:#bbb"> </span>list.append(<span style="color:#099">1</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">try</span><span style="color:#bbb"> </span>list.append(<span style="color:#099">2</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">try</span><span style="color:#bbb"> </span>list.toOwnedSlice();<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>array<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">comptime</span><span style="color:#bbb"> </span>e<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>buffer<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>[<span style="color:#099">1024</span>]<span style="color:#458;font-weight:bold">u8</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">undefined</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">var</span><span style="color:#bbb"> </span>cfba<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>ComptimeFixedBufferAllocator.init(<span style="color:#000;font-weight:bold">&amp;</span>buffer);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>v<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>makeSlice(cfba.allocator())<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">catch</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#0086b3">@compileError</span>(<span style="color:#d14">&#34;allocation error, increase fixed buffer size&#34;</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>};<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">break</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">:</span>e<span style="color:#bbb"> </span>v[<span style="color:#099">0</span>..].<span style="color:#000;font-weight:bold">*</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>};<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>std.debug.print(<span style="color:#d14">&#34;{any}</span><span style="color:#d14">\n</span><span style="color:#d14">&#34;</span>,<span style="color:#bbb"> </span>.{array});<span style="color:#bbb">
</span></span></span></code></pre></div><blockquote>
<p>⚠️ *¡Atención, programador! Ten en cuenta que siempre debes transformar los slices en matrices constantes para evitar incrustar todo el buffer de memoria del allocator en el programa compilado final, fíjate en <code>break :e v[0..].*;</code>. Esto es importante.</p>
</blockquote>
<details>
    <summary>Ver código de ejemplo de un allocator para comptime</summary>
    <div class="inner-summary">
    <p>Es básicamente una copia de <code>std.heap.FixedBufferAllocator</code>. Por cierto, ¿por qué crees que no podemos usarlo en comptime?:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>ComptimeFixedBufferAllocator<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">struct</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>end_index<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">usize</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>buffer<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>[]<span style="color:#458;font-weight:bold">u8</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>init(buffer<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>[]<span style="color:#458;font-weight:bold">u8</span>)<span style="color:#bbb"> </span>ComptimeFixedBufferAllocator<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>ComptimeFixedBufferAllocator{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.buffer<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>buffer,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">0</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>};<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>allocator(self<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span>ComptimeFixedBufferAllocator)<span style="color:#bbb"> </span>std.mem.Allocator<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>.{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.ptr<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>self,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>.vtable<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&amp;</span>.{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">                </span>.alloc<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>alloc,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">                </span>.resize<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>resize,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">                </span>.free<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>free,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>},<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>};<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>isLastAllocation(self<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span>ComptimeFixedBufferAllocator,<span style="color:#bbb"> </span>buf<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>[]<span style="color:#458;font-weight:bold">u8</span>)<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">bool</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>buf.ptr<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>buf.len<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">==</span><span style="color:#bbb"> </span>self.buffer.ptr<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>self.end_index;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>alloc(ctx<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span>anyopaque,<span style="color:#bbb"> </span>n<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">usize</span>,<span style="color:#bbb"> </span>log2_ptr_align<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">u8</span>,<span style="color:#bbb"> </span>ra<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">usize</span>)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">?</span>[<span style="color:#000;font-weight:bold">*</span>]<span style="color:#458;font-weight:bold">u8</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>self<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#0086b3">@ptrCast</span>(<span style="color:#000;font-weight:bold">*</span>ComptimeFixedBufferAllocator,<span style="color:#bbb"> </span><span style="color:#0086b3">@alignCast</span>(<span style="color:#0086b3">@alignOf</span>(ComptimeFixedBufferAllocator),<span style="color:#bbb"> </span>ctx));<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>_<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>ra;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>ptr_align<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#0086b3">@as</span>(<span style="color:#458;font-weight:bold">usize</span>,<span style="color:#bbb"> </span><span style="color:#099">1</span>)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&lt;&lt;</span><span style="color:#bbb"> </span><span style="color:#0086b3">@intCast</span>(std.mem.Allocator.Log2Align,<span style="color:#bbb"> </span>log2_ptr_align);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>adjust_off<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>std.mem.alignPointerOffset(self.buffer.ptr<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>self.end_index,<span style="color:#bbb"> </span>ptr_align)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">orelse</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">null</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>adjusted_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>self.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>adjust_off;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>new_end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>adjusted_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>n;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>(new_end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&gt;</span><span style="color:#bbb"> </span>self.buffer.len)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">null</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>self.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>new_end_index;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span>self.buffer.ptr<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>adjusted_index;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>resize(<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>ctx<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span>anyopaque,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>buf<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>[]<span style="color:#458;font-weight:bold">u8</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>log2_buf_align<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">u8</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>new_size<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">usize</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>return_address<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">usize</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>)<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">bool</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>self<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#0086b3">@ptrCast</span>(<span style="color:#000;font-weight:bold">*</span>ComptimeFixedBufferAllocator,<span style="color:#bbb"> </span><span style="color:#0086b3">@alignCast</span>(<span style="color:#0086b3">@alignOf</span>(ComptimeFixedBufferAllocator),<span style="color:#bbb"> </span>ctx));<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>_<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>log2_buf_align;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>_<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>return_address;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>(<span style="color:#000;font-weight:bold">!</span>self.isLastAllocation(buf))<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>(new_size<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&gt;</span><span style="color:#bbb"> </span>buf.len)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">false</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">true</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>(new_size<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&lt;=</span><span style="color:#bbb"> </span>buf.len)<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>sub<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>buf.len<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>new_size;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>self.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-=</span><span style="color:#bbb"> </span>sub;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">true</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>add<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>new_size<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-</span><span style="color:#bbb"> </span>buf.len;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>(add<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+</span><span style="color:#bbb"> </span>self.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">&gt;</span><span style="color:#bbb"> </span>self.buffer.len)<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">false</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>self.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">+=</span><span style="color:#bbb"> </span>add;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">true</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>free(<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>ctx<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span>anyopaque,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>buf<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span>[]<span style="color:#458;font-weight:bold">u8</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>log2_buf_align<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">u8</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>return_address<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">usize</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>)<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">void</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">const</span><span style="color:#bbb"> </span>self<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#0086b3">@ptrCast</span>(<span style="color:#000;font-weight:bold">*</span>ComptimeFixedBufferAllocator,<span style="color:#bbb"> </span><span style="color:#0086b3">@alignCast</span>(<span style="color:#0086b3">@alignOf</span>(ComptimeFixedBufferAllocator),<span style="color:#bbb"> </span>ctx));<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>_<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>log2_buf_align;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>_<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span>return_address;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#000;font-weight:bold">if</span><span style="color:#bbb"> </span>(self.isLastAllocation(buf))<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>self.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">-=</span><span style="color:#bbb"> </span>buf.len;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#000;font-weight:bold">pub</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">fn</span><span style="color:#bbb"> </span>reset(self<span style="color:#000;font-weight:bold">:</span><span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">*</span>ComptimeFixedBufferAllocator)<span style="color:#bbb"> </span><span style="color:#458;font-weight:bold">void</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>self.end_index<span style="color:#bbb"> </span><span style="color:#000;font-weight:bold">=</span><span style="color:#bbb"> </span><span style="color:#099">0</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>};<span style="color:#bbb">
</span></span></span></code></pre></div>
    </div>
</details>

<p>Recuerda que aunque <code>comptime</code> nos permite realizar algunos trucos poderosos, no es una solución milagrosa. Es simplemente otra herramienta en nuestro kit de herramientas Zig que, cuando se usa adecuadamente, puede conducir a un código más limpio, eficiente y robusto. ¡Pero como siempre, con un gran poder viene una gran responsabilidad! Así que usemos <code>comptime</code> sabiamente&hellip;</p>
<h2 id="limitaciones-de-comptime">Limitaciones de comptime<a hidden class="anchor" aria-hidden="true" href="#limitaciones-de-comptime">#</a></h2>
<p>️🕸️ Hay algunos posibles problemas al usar <code>comptime</code> de los que debes estar al tanto 😅. Los principales son:</p>
<ol>
<li>
<p>Sin operaciones de I/O: Durante el tiempo de compilación, no puedes realizar ninguna operación de entrada/salida. Así es, no puedes leer archivos, escribir en la consola, comunicarte a través de la red, ¡nada! Recuerda, <code>comptime</code> opera en una máquina abstracta idealizada sin acceso al mundo exterior. 🌐🔒</p>
</li>
<li>
<p>Sin acceso a variables de entorno: De manera similar, <code>comptime</code> no tiene acceso a las variables de entorno en tiempo de ejecución. Esto incluye cosas como la hora del sistema, el identificador del proceso o las variables de entorno específicas del usuario. ¡Todo se trata del código, amigos! 🖥️🚫</p>
</li>
<li>
<p>Asignación de memoria: Hablamos antes de cómo <code>comptime</code> gestiona la memoria y la falta de un allocator para comptime. Es importante recordar que <code>comptime</code> y el tiempo de ejecución son dos dominios diferentes. 🧙‍♂️🏰</p>
</li>
</ol>
<hr>
<p>¡Y ya está, amigos!. Un profundo viaje al mundo mágico de <code>comptime</code> en Zig. Espero que hayas disfrutado nuestro recorrido y que ahora estés tan entusiasmado con <code>comptime</code> como yo. Recuerda, el aprendizaje es un proceso continuo, así que nunca dejes de explorar y experimentar con Zig. ¡Sigue codificando con pasión y creatividad! 🚀💻</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://d4c7.github.io/zig-zagueando/posts/webassembly-y-zig-comenzando/">
    <span class="title">Siguiente »</span>
    <br>
    <span>WebAssembly y Zig: Comenzando 🕸️🚀</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Zig comptime on twitter"
        href="https://twitter.com/intent/tweet/?text=Zig%20comptime&amp;url=https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Zig comptime on twitter"
        href="https://mastodon.social/share?text=Zig%20comptime&amp;url=https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f&amp;hashtags=">
        <svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 134.98711 134.98711"  height="30px" width="30px" fill="currentColor">
            <path
            id="path173"
            style="stroke-width:0.263647"
            d="m 16.731795,0.23977865 c -9.1024158,0 -16.49201635,7.38992375 -16.49201635,16.49201635 V 118.73487 c 0,9.10226 7.38985565,16.49202 16.49201635,16.49202 H 118.73487 c 9.10214,0 16.49202,-7.38976 16.49202,-16.49202 V 16.731795 c 0,-9.1020926 -7.38961,-16.49201635 -16.49202,-16.49201635 z M 67.439294,10.841715 c 14.33843,-0.05813 28.783417,1.646195 36.594666,5.294251 0,0 15.91014,7.255352 15.91014,31.968591 0,0 0.20549,18.227747 -2.23449,30.892688 -1.55702,8.036749 -13.76419,16.8293 -27.786933,18.533753 -5.022382,0.607318 -23.265943,3.605592 -44.66084,-1.706356 -0.0048,1.181997 0.06971,2.368525 0.222208,3.541903 1.656724,12.607705 12.293926,13.366905 22.390882,13.722155 10.191884,0.33227 18.422648,-2.56831 18.422648,-2.56831 l 0.42633,9.38289 c 0,0 -6.280354,3.89032 -18.978686,4.60798 -6.997135,0.4035 -15.701008,-0.18203 -25.82168,-2.90215 -26.42692,-7.14414 -26.405106,-44.08773 -26.405106,-73.505069 0,-24.71324 15.937528,-31.968075 15.937528,-31.968075 7.40775,-3.415535 21.644915,-5.240421 35.983333,-5.294251 z m 15.973702,18.845362 c -4.915817,0.118459 -9.781729,2.307054 -12.784232,6.975801 L 67.745219,41.57679 64.852372,36.662878 C 61.861733,32.020326 57.007083,29.816291 52.094495,29.690694 v -0.0016 c -4.9126,-0.131685 -9.884165,1.806349 -13.109794,5.442562 -5.881561,6.821562 -4.589384,11.286347 -4.589384,42.018624 h 11.644767 v -26.7208 c 0,-12.50759 15.938045,-12.98127 15.938045,1.74408 V 67.656852 H 73.521094 V 52.17356 c 0,-14.724632 15.947347,-14.241724 15.947347,-1.733228 v 26.72085 h 11.617379 v -0.0098 c 0,-30.708592 1.31591,-35.144851 -4.589384,-42.018624 -3.201876,-3.612175 -8.167622,-5.564121 -13.08344,-5.445662 z" />    
       </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Zig comptime on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f&amp;title=Zig%20comptime&amp;summary=Zig%20comptime&amp;source=https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Zig comptime on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f&title=Zig%20comptime">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Zig comptime on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Zig comptime on whatsapp"
        href="https://api.whatsapp.com/send?text=Zig%20comptime%20-%20https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Zig comptime on telegram"
        href="https://telegram.me/share/url?text=Zig%20comptime&amp;url=https%3a%2f%2fd4c7.github.io%2fzig-zagueando%2fposts%2fzig-comptime%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer><div>
    <p>¡Te invitamos a participar en la discusión! ¿Tienes preguntas, ideas o experiencias para compartir sobre el post? ¡No dudes en dejar tus comentarios y unirte a la conversación! Queremos escuchar tu perspectiva y enriquecer nuestra comunidad con tus aportes. ¡No te quedes sin participar, tu voz es importante!</p>

    <div class="share-buttons">
        <a target="_blank" rel="noopener noreferrer" aria-label="Comentarios de Zig comptime" href="https://github.com/d4c7/zig-zagueando/discussions/categories/zig-comptime">
           <p>Ver los comentarios 💬</p>
        </a>
    </div>
</div>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://d4c7.github.io/zig-zagueando/">Zig-zagueando Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copiar';

        function copyingDone() {
            copybutton.innerHTML = '¡copiado!';
            setTimeout(() => {
                copybutton.innerHTML = 'copiar';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
