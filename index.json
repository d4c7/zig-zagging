[{"content":"¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮\n¿Qué es comptime? El término comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al español, sería \u0026ldquo;Tiempo de Compilación\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante. En Zig, puedes decidir qué parte de tu código se ejecutará en tiempo de compilación y cuál en tiempo de ejecución. 🕓\nPrincipales ventajas de comptime Quizás te estés preguntando, ¿por qué querríamos hacer cálculos en tiempo de compilación?\nFlexibilidad: Gracias a comptime, puedes generar código en tiempo de compilación de forma dinámica. Esto significa que puedes decidir cómo se comportará tu programa en función de las condiciones existentes durante la compilación. 😏\nEficiencia: Al mover ciertas operaciones al tiempo de compilación, puedes mejorar significativamente la eficiencia de tu código en tiempo de ejecución. En lugar de calcular algo cada vez que se ejecuta tu programa, lo calculas una vez durante la compilación y ya está. Es como preparar toda la comida de antemano para que, cuando lleguen los invitados, ¡solo tengas que encender el fuego! 🍳⏲️\nSeguridad: comptime puede ayudarte a detectar errores en tiempo de compilación en lugar de en tiempo de ejecución. Cuanto antes detectes los errores, más segura será tu aplicación. 💪\nAbstracción sin costo: A diferencia de otros lenguajes que pagan un precio por abstracciones de alto nivel (con rendimiento más lento o más memoria usada), Zig permite abstracciones sin costos adicionales, gracias al poder de comptime.🎉\nEjemplo básico de uso de comptime En su forma más básica comptime es la forma en la que una variable se calcula en tiempo de compilación para convertirse en una constante en tiempo de ejecución. Aquí hay un pequeño fragmento de código para que te hagas una idea de cómo se utiliza comptime.\n⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\nfn suma() u64 { var r: u64 = 0; for (1..100) |i| { r += i; } return r; } pub fn main() void { var s = comptime suma(); std.debug.print(\u0026#34;{}\u0026#34;, .{s}); sumaB(); } Cuando compiles este código, verás que suma se calcula en tiempo de compilación y su resultado es simplemente una constante. En tiempo de ejecución, este bloque comptime no tiene ningún efecto.\nexample.main: push rbp mov rbp, rsp sub rsp, 16 mov qword ptr [rbp - 8], 4950 call debug.print__anon_3471 add rsp, 16 pop rbp ret Explicación del código Este código es esamblador de arquitectura x86-64 (o AMD64):\npush rbp: Guarda el valor actual del puntero base del marco (frame base pointer) en la pila. Esto se hace generalmente al inicio de una función para preservar el valor actual de rbp para poder restaurarlo más tarde.\nmov rbp, rsp: Establece el puntero base del marco al valor actual del puntero de la pila (stack pointer). Esto se hace para que la función tenga un punto de referencia fijo para acceder a las variables locales y los argumentos.\nsub rsp, 16: Reserva 16 bytes en la pila para las variables locales de esta función, moviendo el puntero de la pila hacia abajo (en la mayoría de las arquitecturas, la pila crece hacia abajo en la memoria).\nmov qword ptr [rbp - 8], 4950: Guarda el valor 4950 en la ubicación de la pila 8 bytes por debajo del puntero base del marco. Probablemente esto está inicializando una variable local.\ncall debug.print__anon_3471: Llama a la función debug.print__anon_3471. Esta función pinta el valor de la variable local que acabamos de inicializar.\nadd rsp, 16: Restablece el puntero de la pila a su posición antes de que reserváramos espacio para las variables locales. Esto efectivamente \u0026ldquo;libera\u0026rdquo; ese espacio de la pila.\npop rbp: Restaura el puntero base del marco a su valor antes de la llamada a la función, esencialmente limpiando después de que la función haya terminado.\nret: Retorna de la función, saltando de vuelta a la dirección de retorno almacenada en la pila por la instrucción call que llamó a esta función.\nOtra forma de asignar un cáculo en comptime a una variable o constate es usando break :equita valor en un bloque:\nvar s = comptime e: { var r: u64 = 0; for (1..100) |i| { r += i; } break :e r; }; ¿Pero que pasaría si nos encontramos un bucle demasiado largo en tiempo de compilación? Comptime tiene un limitador de la cantidad de ramificaciones que se pueden evaluar en tiempo de compilación, lo cual es útil para prevenir bucles infinitos y otros problemas que pueden consumir una cantidad excesiva de recursos durante la compilación. Se puede cambiar el límite con la función @setEvalBranchQuota(), que por defecto es 1000.\nCombiene recordarlo si nos encontramos con un error similar a este compilando:\nerror: evaluation exceeded 1000 backwards branches note: use @setEvalBranchQuota() to raise the branch limit from 1000 Comparación con tiempo de ejecución Entonces, ¿cómo se compara comptime con los cálculos en tiempo de ejecución tradicionales? Cuando un programa Zig se está ejecutando, a menudo hay decisiones que tomar, como elegir qué ramas de código ejecutar. Normalmente, esto ocurre en tiempo de ejecución, pero con comptime, estas decisiones se pueden tomar en tiempo de compilación. Es como resolver la mayor parte del rompecabezas antes de que empiece a correr el reloj. ⏳🧩\nAplicaciones prácticas de comptime De acuerdo, la teoría es buena, ¡pero veamos comptime en acción! Te guiaré a través de algunos ejemplos prácticos donde comptime puede brillar, como cuando trabajas con metaprogramación o programación genérica. ¡Aquí es donde comptime pasa de ser simplemente \u0026lsquo;genial\u0026rsquo; a \u0026lsquo;absolutamente fantástico\u0026rsquo;! 🌟🔧\nQué es @compileLog En Zig, @compileLog es una función incorporada que te permite registrar mensajes durante el tiempo de compilación. Es una herramienta maravillosa para la depuración o para entender lo que está sucediendo en tiempo de compilación. Aquí tienes un ejemplo rápido:\ncomptime { const a = 5; @compileLog(\u0026#34;Valor de a en tiempo de compilación: \u0026#34;, a); } En el código anterior, @compileLog imprimirá el mensaje \u0026ldquo;Valor de a en tiempo de compilación: 5\u0026rdquo; durante el proceso de compilación. ¡Esto puede ser muy útil cuando estás lidiando con expresiones o funciones comptime complejas! 🤔💭\nHay que hace notar que, a día de hoy, la compilación fallará si se ha ejecutado cualquier @compileLog. La razón es evitar que las librerías polucionen de mensajes la compilación de un programa.\nQué es @compileError @compileError es otra función incorporada en Zig que se utiliza para lanzar un error en tiempo de compilación. Esto es súper útil para asegurar ciertas condiciones durante el tiempo de compilación y detener la compilación si no se cumplen. Así es cómo puedes usarlo:\ncomptime { if (!std.builtin.target.isWasm()) { @compileError(\u0026#34;WasmPageAllocator is only available for wasm32 arch\u0026#34;); } } En este ejemplo, si la arquitectura en la se está intentando compilar el programa no es la adecuada se lanzará un error de compilación con @compileError 💥🛑\nComptime para metaprogramación La metaprogramación se refiere a la capacidad de un programa para tratar su código como datos y manipularlo. En Zig, comptime proporciona una forma poderosa de lograr la metaprogramación. Por ejemplo, puedes generar funciones especializadas para diferentes tipos:\nfn createAdder(comptime T: type) type { return struct { fn add(a: T, b: T) T { return a + b; } }; } const IntAdder = createAdder(i32); const FloatAdder = createAdder(f32); var i = IntAdder.add(10, 20); var f = FloatAdder.add(1.0, 2.0); En el código anterior, estamos generando dos estructuras en tiempo de compilación: IntAdder y FloatAdder. Cada una tiene una función add, pero trabajan con tipos diferentes (i32 y f32). ¡Esto es solo la punta del iceberg cuando se trata de metaprogramación con comptime! 🧠🔮\nPor ejemplo, podemos crear estructuras completas en tiempo de compilación:\nfn makeType(comptime n: usize) type { var fields: [n]std.builtin.Type.StructField = undefined; inline for (0..n) |v| { const default_value: u32 = v; fields[v] = .{ .name = std.fmt.comptimePrint(\u0026#34;field{}\u0026#34;, .{v}), .type = @TypeOf(default_value), .default_value = @ptrCast(*const anyopaque, \u0026amp;default_value), .is_comptime = false, .alignment = @alignOf(@TypeOf(default_value)), }; } return @Type(.{ .Struct = .{ .layout = .Auto, .fields = fields[0..], .decls = \u0026amp;.{}, .is_tuple = false, } }); } const T2 = comptime makeType(2); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T2{}}); const T3 = comptime makeType(3); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T3{}}); sample.makeType(2){ .field0 = 0, .field1 = 1 } sample.makeType(3){ .field0 = 0, .field1 = 1, .field2 = 2 } Detalles importantes en este código:\nLa matriz fields tiene un tamaño fijo determinado en tiempo de compilación.\nEl bucle inline for itera sobre el rango 0..n. Es por tanto un bucle que se desenrrolla. ¿Crees que es obligatorio este desenrollado? ¿En necesario?\nComptime y asignación de memoria Lo ideal sería poder utilizar todas las estructuras de datos disponibles en Zig para poder ejectuar cálculos en tiempo de compilación. Aunque de momento no existe en la librería estándar un asignador de memoria (allocator) de Zig en para tiempo de compilación, podemos implementar el nuestro propio con facilidad. Así, con un poco de cuaidado, podremos usar en comptime, de forma auxilia,r estructuras como std.ArrayList:\nfn makeSlice(allocator: std.mem.Allocator) ![]u8 { var list = std.ArrayList(u8).init(allocator); defer list.deinit(); try list.append(1); try list.append(2); return try list.toOwnedSlice(); } const array = comptime e: { var buffer: [1024]u8 = undefined; var cfba = ComptimeFixedBufferAllocator.init(\u0026amp;buffer); const v = makeSlice(cfba.allocator()) catch { @compileError(\u0026#34;allocation error, increase fixed buffer size\u0026#34;); }; break :e v[0..].*; }; std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{array}); ⚠️ ¡Atención, programador! Ten en cuenta que siempre debes transformar los slices en matrices constantes para evitar incrustar todo el buffer de memoria del allocator en el programa compilado final, fíjate en break :e v[0..].*;. Esto es importante.\nVer código de ejemplo de un allocator para comptime Es básicamente una copia de std.heap.FixedBufferAllocator. Por cierto, ¿por qué crees que no podemos usarlo en comptime?:\npub const ComptimeFixedBufferAllocator = struct { end_index: usize, buffer: []u8, pub fn init(buffer: []u8) ComptimeFixedBufferAllocator { return ComptimeFixedBufferAllocator{ .buffer = buffer, .end_index = 0, }; } pub fn allocator(self: *ComptimeFixedBufferAllocator) std.mem.Allocator { return .{ .ptr = self, .vtable = \u0026amp;.{ .alloc = alloc, .resize = resize, .free = free, }, }; } pub fn isLastAllocation(self: *ComptimeFixedBufferAllocator, buf: []u8) bool { return buf.ptr + buf.len == self.buffer.ptr + self.end_index; } fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = ra; const ptr_align = @as(usize, 1) \u0026lt;\u0026lt; @intCast(std.mem.Allocator.Log2Align, log2_ptr_align); const adjust_off = std.mem.alignPointerOffset(self.buffer.ptr + self.end_index, ptr_align) orelse return null; const adjusted_index = self.end_index + adjust_off; const new_end_index = adjusted_index + n; if (new_end_index \u0026gt; self.buffer.len) return null; self.end_index = new_end_index; return self.buffer.ptr + adjusted_index; } fn resize( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, new_size: usize, return_address: usize, ) bool { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (!self.isLastAllocation(buf)) { if (new_size \u0026gt; buf.len) return false; return true; } if (new_size \u0026lt;= buf.len) { const sub = buf.len - new_size; self.end_index -= sub; return true; } const add = new_size - buf.len; if (add + self.end_index \u0026gt; self.buffer.len) return false; self.end_index += add; return true; } fn free( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, return_address: usize, ) void { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (self.isLastAllocation(buf)) { self.end_index -= buf.len; } } pub fn reset(self: *ComptimeFixedBufferAllocator) void { self.end_index = 0; } }; Recuerda que aunque comptime nos permite realizar algunos trucos poderosos, no es una solución milagrosa. Es simplemente otra herramienta en nuestro kit de herramientas Zig que, cuando se usa adecuadamente, puede conducir a un código más limpio, eficiente y robusto. ¡Pero como siempre, con un gran poder viene una gran responsabilidad! Así que usemos comptime sabiamente\u0026hellip;\nLimitaciones de comptime ️🕸️ Hay algunos posibles problemas al usar comptime de los que debes estar al tanto 😅. Los principales son:\nSin operaciones de I/O: Durante el tiempo de compilación, no puedes realizar ninguna operación de entrada/salida. Así es, no puedes leer archivos, escribir en la consola, comunicarte a través de la red, ¡nada! Recuerda, comptime opera en una máquina abstracta idealizada sin acceso al mundo exterior. 🌐🔒\nSin acceso a variables de entorno: De manera similar, comptime no tiene acceso a las variables de entorno en tiempo de ejecución. Esto incluye cosas como la hora del sistema, el identificador del proceso o las variables de entorno específicas del usuario. ¡Todo se trata del código, amigos! 🖥️🚫\nAsignación de memoria: Hablamos antes de cómo comptime gestiona la memoria y la falta de un allocator para comptime. Es importante recordar que comptime y el tiempo de ejecución son dos dominios diferentes. 🧙‍♂️🏰\n¡Y ya está, amigos!. Un profundo viaje al mundo mágico de comptime en Zig. Espero que hayas disfrutado nuestro recorrido y que ahora estés tan entusiasmado con comptime como yo. Recuerda, el aprendizaje es un proceso continuo, así que nunca dejes de explorar y experimentar con Zig. ¡Sigue codificando con pasión y creatividad! 🚀💻\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-comptime/","summary":"¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮\n¿Qué es comptime? El término comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al español, sería \u0026ldquo;Tiempo de Compilación\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante.","title":"Zig comptime"},{"content":"¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). Prepárate para desbloquear el poder de Zig en el navegador! 🌐💪\n¿Qué es WebAssembly? 🧐 WebAssembly es un formato de instrucción binaria diseñado como un objetivo portable para la compilación de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar código en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.\n¿Por qué Zig con WebAssembly? 🤔 La simplicidad, eficiencia y robustez de Zig lo convierten en una excelente elección para el desarrollo de WebAssembly. La capacidad de Zig para compilar cruzadamente sin problemas es una enorme ventaja, y su fuerte enfoque en la seguridad es perfecto para el entorno protegido de la web.\nEmpezando con Zig y WebAssembly 🚀 Vamos a crear un simple programa Zig y compilarlo a WebAssembly.\nComienza escribiendo un simple programa Zig. Abre tu editor de código y crea un nuevo archivo llamado hello.zig: ⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\nextern fn print(a: i32) void; export fn add(a: i32, b: i32) i32 { print(1234); return a + b; } Este código establece una interfaz entre Zig y JavaScript. La declaración extern fn print(a: i32) void; permite a Zig usar la función print de JavaScript, y export fn add(a: i32, b: i32) i32 { ... } proporciona una función que puede ser llamada desde JavaScript.\nPara compilar este código Zig a WebAssembly, añade un archivo build.zig const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const target = std.zig.CrossTarget{ .cpu_arch = .wasm32, .os_tag = .freestanding, .abi = .musl, }; const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = .ReleaseFast }); const lib = b.addSharedLibrary(.{ .name = \u0026#34;hello\u0026#34;, .root_source_file = .{ .path = \u0026#34;./hello.zig\u0026#34; }, .target = target, .optimize = optimize, }); lib.rdynamic = true; b.installArtifact(lib); } Vamos a verlo con detalle:\nconst std = @import(\u0026quot;std\u0026quot;);\nAquí estamos importando la biblioteca estándar de Zig (std). Esto nos da acceso a todas las funciones y utilidades proporcionadas por la biblioteca estándar. 📚🔍\npub fn build(b: *std.build.Builder) void {\nEn esta línea, definimos la función principal build para nuestro script de compilación, que recibe un puntero a una instancia de std.build.Builder. Este es nuestro guía para la aventura de la construcción de código. 🏗️🗺️\nconst target = std.zig.CrossTarget{...};\nAquí estamos creando un objetivo de compilación cruzada para WebAssembly con el tag del sistema operativo freestanding y la interfaz binaria de aplicación musl. Esta es la maleta que preparamos para nuestro viaje a WebAssembly Land. 🛄🎯\nconst optimize = b.standardOptimizeOption(...);\nAquí definimos las opciones de optimización. Estamos eligiendo la opción de optimización ReleaseFast, que es como decir \u0026ldquo;¡Vamos a correr como el viento, pero sin tropezar!\u0026rdquo; 🏃‍♂️💨\nconst lib = b.addSharedLibrary(...);\nEn este paso, le decimos a nuestro guía (el constructor b) que queremos construir una biblioteca compartida llamada hello a partir del archivo de origen hello.zig, con las opciones de objetivo y optimización que definimos anteriormente. Es como pedirle a nuestro guía que prepare los planes para construir un puente a WebAssembly Land. 🌉🛠️\nlib.rdynamic = true;\nLa opción rdynamic es absolutamente necesaria en Zig 0.11.0, ya que el linker de wasm integrado en Zig no exporta los símbolos definidos. La opción rdynamic sirve para enlazar dinamicamente librerías y es particularmente útil cuando quieres exportar símbolos desde un ejecutable. El uso de esta opción en el contexto de WebAssembly es una solución (workaround) a este problema.\nb.installArtifact(lib);\nFinalmente, le decimos a nuestro guía que instale la biblioteca que acabamos de construir. Esto coloca nuestra hermosa biblioteca hello en el lugar correcto para que otros puedan usarla. Es como colocar nuestro puente recién construido en el mapa para que todos puedan encontrarlo. 🗺️🌉\nPara construir el proyecto teclea el siguiente comando:\nzig build Tenemos nuestro módulo listo, ahora vamos por el HTML y Javascript. Creamos un archivo index.html: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Zig: ¡Hola WASM!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;Zig: ¡Hola WASM!\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;(¡Abre la consola!)\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;loader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Creamos un script de carga para cargar y ejecutar nuestro módulo WebAssembly. Creamos un nuevo archivo en el mismo directorio llamado loader.js: WebAssembly.instantiateStreaming(fetch(\u0026#39;zig-out/lib/hello.wasm\u0026#39;), { env: { print: function (x) { console.log(\u0026#34;Llamada desde zig:\u0026#34;, x); } } }).then(result =\u0026gt; { const add = result.instance.exports.add; console.log(\u0026#34;Llamada a Zig:\u0026#34;, add(3, 5)); }); Este código muestra cómo se puede cargar y ejecutar un módulo WebAssembly en un entorno de navegador. Para ello, se prepara una solicitud HTTP GET al archivo .wasm que se pasa a WebAssembly.instantiateStreaming para descargar, compilar y ejecutar el módulo.\nEl objeto de importación que se pasa a WebAssembly.instantiateStreaming representa el entorno del host. En este caso, proporcionamos una función de impresión que se puede llamar desde el módulo WebAssembly. Una vez que el módulo se ha instanciado correctamente, podemos acceder a las funciones exportadas y llamarlas como cualquier otra función de JavaScript.\nInicia cualquier servidor HTTP Debido a las políticas de CORS en la mayoría de los navegadores, es necesario servir nuestro módulo WebAssembly a través de un servidor HTTP. Puedes hacerlo fácilmente con Python ejecutando el comando:\n$ python -m SimpleHTTPServer 8001 Navega a http://localhost:8001 en tu navegador, y estarás listo para ver el funcionamiento de tu programa.\n¡Y eso es todo! Acabas de escribir tu primer programa Zig para WebAssembly. 🎉\nQuiero más 🌟 Atentos a nuestros próximos posts, donde iremos un paso más allá y construiremos juntos y poco a poco un clásico: ¡El juego ese de bloques que caen de arriba! No solo será una oportunidad para divertirnos mientras programamos, sino también una forma efectiva de aprender y profundizar en nuestros conocimientos sobre WebAssembly, Zig, juegos, IA, algoritmos, estructuras de datos, usabilidad y muchos otros.\n¡Pruébalo un poco para ir abriendo el apetito!\nEspero que esta publicación te haya proporcionado una sólida introducción a WebAssembly y Zig. ¡Nos vemos en la próxima!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/webassembly-y-zig-comenzando/","summary":"¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). Prepárate para desbloquear el poder de Zig en el navegador! 🌐💪\n¿Qué es WebAssembly? 🧐 WebAssembly es un formato de instrucción binaria diseñado como un objetivo portable para la compilación de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar código en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.","title":"WebAssembly y Zig: Comenzando 🕸️🚀"},{"content":"¡Hola, entusiastas de Zig! 👋 En nuestra publicación anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazón de la gestión de proyectos de Zig: el sistema de construcción de Zig. ¡Empecemos! 🎉\n¿Qué es el sistema de construcción de Zig? 🤔 El sistema de construcción de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos. Simplifica procesos de construcción complejos y proporciona una compilación cruzada sin interrupciones, permitiéndote apuntar a diferentes plataformas con facilidad.\nEmpezando con build.zig 🚀 Para aprovechar el sistema de construcción de Zig, necesitas crear un archivo build.zig en el directorio raíz de tu proyecto.\nEl conjunto de herramientas de Zig (toolchain) llama a la función build(b: *std.Build) void de build.zig. El parámetro bse utiliza para configurar y definir el proceso de construcción mediante pasos o instrucciones que no formen ciclos o bucles.\nPor ejemplo, podemos crear nuestro propio paso my-step:\n⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const my_step = b.step(\u0026#34;my-step\u0026#34;, \u0026#34;Este paso es mi paso\u0026#34;); _ = my_step; } Este paso aparecerá en la ayuda si ejecutamos zig build --help, y aunque no hace nada, hace mucha ilusión.\n$ zig build --help Usage: zig build [steps] [options] Steps: install (default) Copy build artifacts to prefix path uninstall Remove build artifacts from prefix path my-step Este paso es mi paso [...] Project-Specific Options: (none) [...] También podemos observar en la ayuda una sección Project-Specific Options, que por ahora aparece vacía.\nAñadiendo el primer paso 👣 Zig viene equipado con algunos pasos listos para usar. Uno de los más interesantes es addExecutable, que permite compilar un ejecutable o librería.\nSi añadimos este main.zig al directorio:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;Hola otra vez\\n\u0026#34;, .{}); } Y definimos build.zig como:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;my-executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); } Cuando ejecutemos el comando zig build se compilará nuestro ejecutable. Estas son las líneas principales:\nconst target = b.standardTargetOptions(.{}): Define las opciones de destino que estarán disponibles y cual será la de defecto, lo que permite al usuario seleccionar para qué plataforma se va a construir el código.\nconst optimize = b.standardOptimizeOption(.{}): Define las opciones de optimización estándar, lo que permite al usuario seleccionar el nivel de optimización para la compilación.\nconst exe = b.addExecutable(.): Añade un ejecutable al proceso de construcción. Los parámetros definen cómo se construirá el ejecutable, incluyendo el archivo fuente principal, las opciones de destino y las opciones de optimización.\nb.installArtifact(exe): Esta línea declara que el ejecutable creado en el paso anterior debe ser instalado en la ubicación estándar cuando se realiza el paso de instalación.\nSi volvemos a ejecutar zig build --help observaremos como ahora la sección Project-Specific Options muestra opciones para establecer la plataforma, características de la cpu y la optimización desde línea de comandos.\nProject-Specific Options: -Dtarget=[string] The CPU architecture, OS, and ABI to build for -Dcpu=[string] Target CPU features to add or subtract -Doptimize=[enum] Prioritize performance, safety, or binary size (-O flag) Supported Values: Debug ReleaseSafe ReleaseFast ReleaseSmall Al lanzar zig build se generarán dos directorios importantes:\nzig-cache: Este directorio contiene artefactos de construcción intermedios, como archivos de objeto, y es utilizado por el sistema de construcción de Zig para almacenar en caché los resultados de la construcción y acelerar las compilaciones posteriores. zig-out: Este directorio almacena la salida final de tu proceso de construcción, incluyendo ejecutables, bibliotecas y otros binarios. Compilación cruzada hecha fácil 🌉 Una de las características más poderosas del sistema de construcción de Zig es su capacidad para compilar de forma cruzada tus proyectos. Para ello simplemente proporciona la opción --target cuando ejecutes zig build:\nzig build -Dtarget=aarch64-linux-gnu Este comando compila tu proyecto para la plataforma objetivo especificada, manejando todas las complejidades por ti. 🎉\n$ file zig-out/bin/executable zig-out/bin/executable: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped Añadiendo más pasos 👣👣 Ahora que sabemos como funciona podemos añadir otros dos pasos, uno para ejecutar el programa y otro para lanzar los tests:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { // compilación const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); // ejecución const run_cmd = b.addRunArtifact(exe); if (b.args) |args| { run_cmd.addArgs(args); } run_cmd.step.dependOn(b.getInstallStep()); const run_step = b.step(\u0026#34;run\u0026#34;, \u0026#34;Run the app\u0026#34;); run_step.dependOn(\u0026amp;run_cmd.step); // tests const unit_tests = b.addTest(.{ .root_source_file = .{ .path = \u0026#34;main_test.zig\u0026#34; }, .target = target, .optimize = optimize, }); const run_unit_tests = b.addRunArtifact(unit_tests); const test_step = b.step(\u0026#34;test\u0026#34;, \u0026#34;Run unit tests\u0026#34;); test_step.dependOn(\u0026amp;run_unit_tests.step); } En este código podemos ver\nEl bloque if (b.args) |args| {...}: Añade cualquier argumento pasado al comando de ejecución.\nconst run_step = b.step(\u0026quot;run\u0026quot;, \u0026quot;Run the app\u0026quot;): Crea un paso de construcción que ejecuta el comando de ejecución.\nconst unit_tests = b.addTest(.) y const run_unit_tests = b.addRunArtifact(unit_tests): Crea un paso para las pruebas unitarias. Este paso construye el ejecutable de prueba pero no lo ejecuta.\nconst test_step = b.step(\u0026quot;test\u0026quot;, \u0026quot;Run unit tests\u0026quot;): Este paso ejecuta las pruebas unitarias.\nPara añadir los test añadimos el archivo main_test.zig:\nconst std = @import(\u0026#34;std\u0026#34;); test \u0026#34;simple test\u0026#34; { try std.testing.expect(addOne(41) == 42); } fn addOne(number: i32) i32 { return number + 1; } Para crear un caso de prueba en Zig, usa la palabra clave test, seguida de un nombre de prueba y un bloque de código.\nPara lanzar los test usamos el comando zig build test. Si todo va bien no deberíamos ver ningún error, el comando es realmente muy silencioso.\n¿Se puede más fácil? 😅 Crear un archivo build.zig puede ser un poco tedioso, más aun cuando todavía no dominamos el lenguaje. Pero no tienes por qué empezar desde cero. El comando zig init-exe te generará las carpetas y archivos necesarios para compilar, ejecutar y pasar los test de un proyecto de básico de ejemplo en el directorio donde te encuentres.\n¿Qué sigue? 🌟 ¡Eso es todo! Ahora tienes un sólido entendimiento del sistema de construcción de Zig y puedes usarlo para gestionar, construir y compilar de forma cruzada tus proyectos con facilidad. 💡\n¡Feliz codificación y nos vemos en la próxima publicación! 👩‍💻👨‍💻🚀\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/una-gu%C3%ADa-del-sistema-de-construcci%C3%B3n-en-zig/","summary":"¡Hola, entusiastas de Zig! 👋 En nuestra publicación anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazón de la gestión de proyectos de Zig: el sistema de construcción de Zig. ¡Empecemos! 🎉\n¿Qué es el sistema de construcción de Zig? 🤔 El sistema de construcción de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos.","title":"Una guía del sistema de construcción de Zig 🏗️"},{"content":"¡Saludos, entusiastas de Zig! 👋 Es el momento de configurar un entorno de desarrollo cómodo para mejorar tu experiencia de programación en Zig. En esta publicación, te guiaré para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo edición de código, ejecución y depuración. ¡Sumérgete en el tema! 🚀\nConfigurando Visual Studio Code para el desarrollo en Zig 🛠️ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:\nInstala Visual Studio Code: Si aún no lo has hecho, descarga e instala Visual Studio Code para tu plataforma (Linux, Windows o macOS).\nInstala la extensión de Zig: Abre el buscador rápido de VS Code (Ctrl+P), pega el siguiente comando y presiona enter.\next install ziglang.vscode-zig Configura los ajustes: Para configurar los ajustes de la extensión de Zig, abre el editor de Configuración haciendo clic en el ícono de engranaje en la esquina inferior izquierda de la ventana y selecciona \u0026ldquo;Configuración\u0026rdquo;. Busca \u0026ldquo;Zig\u0026rdquo; en la barra de búsqueda y actualiza los ajustes según sea necesario. Por ejemplo, es posible que desees establecer la ruta del compilador de Zig si no está en la ubicación predeterminada. ¡Listo! Ahora estás listo para desarrollar en Zig en VS Code. 🎉\nEjecutando y depurando código 🏃‍♀️💻 Para ejecutar y depurar código Zig en VS Code, sigue estos pasos:\nCrea un nuevo archivo Zig: Abre VS Code y crea un nuevo archivo con la extensión .zig, como main.zig.\nEscribe código Zig: Escribe un programa sencillo en Zig en tu nuevo archivo, como un programa \u0026ldquo;Hola, mundo\u0026rdquo;:\n⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { std.debug.print(\u0026#34;Hello, {s}!\\n\u0026#34;, .{\u0026#34;World\u0026#34;}); } Configura tasks.json: Para ejecutar tu código Zig, necesitas crear un archivo tasks.json en la carpeta .vscode de tu espacio de trabajo. Agrega la siguiente configuración al archivo: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;zig build-exe main.zig\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuración define tareas para Visual Studio Code. Las tareas se utilizan para automatizar el proceso de construcción, prueba y despliegue de tu aplicación. En este caso, estamos definiendo la tarea de compilación:\n\u0026quot;label\u0026quot;: \u0026quot;build\u0026quot; - Es el nombre que se le da a la tarea. En este caso, la tarea se llama \u0026ldquo;build\u0026rdquo;. \u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot; - Especifica que esta tarea se ejecutará en una shell o terminal. \u0026quot;command\u0026quot;: \u0026quot;zig build-exe main.zig\u0026quot; - Es el comando que se ejecutará cuando se inicie esta tarea. Este comando compilará el archivo main.zig en un ejecutable utilizando el compilador Zig. \u0026quot;group\u0026quot;: \u0026quot;build\u0026quot; - Esto agrupa la tarea en la categoría \u0026ldquo;build\u0026rdquo;. Las tareas se pueden agrupar para un fácil acceso y gestión en Visual Studio Code. Ejecuta tu código Zig: Presiona Ctrl+Shift+B (o Cmd+Shift+B en macOS) para ejecutar la tarea \u0026ldquo;build\u0026rdquo;, que compila tu código Zig. Salida:\n* Executing task: zig build-exe \u0026lt;...\u0026gt;/main.zig * Terminal will be reused by tasks, press any key to close it. Depuración: Para depurar tu código Zig, primero debes instalar las extensiones \u0026ldquo;Native Debug\u0026rdquo; de WebFreak y \u0026ldquo;CodeLLDB\u0026rdquo; de Vadim Chugunov. Presiona ctrl-p (cmd+p en macOS) y ejecuta los siguientes comandos:\next install webfreak.debug y\next install vadimcn.vscode-lldb Una vez instaladas, crea un archivo launch.json en la carpeta .vscode de tu espacio de trabajo con la siguiente configuración:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug Zig\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuración de lanzamiento se usa para definir cómo se debe depurar un proyecto. El campo configurations tiene una lista de diferentes configuraciones de depuración que puedes usar. Puedes cambiar entre estas configuraciones en el menú desplegable de depuración en la parte superior de VS Code. La configuración se define así:\nname: Es el nombre que aparece en el menú desplegable de depuración. En este caso, está configurado como \u0026ldquo;Debug Zig\u0026rdquo;, lo que indica que esta configuración es para depurar programas escritos en Zig. type: Define el depurador que se utilizará. En este caso, \u0026ldquo;lldb\u0026rdquo; indica que se utilizará el depurador LLDB de LLVM. request: Puede ser \u0026ldquo;launch\u0026rdquo; o \u0026ldquo;attach\u0026rdquo;. \u0026ldquo;launch\u0026rdquo; inicia el programa en el depurador, mientras que \u0026ldquo;attach\u0026rdquo; se conecta a un proceso ya en ejecución. En la configuración el valor es \u0026ldquo;launch\u0026rdquo;, por lo que el depurador iniciará el programa. program: Es el nombre del programa que se va a iniciar. En esta configuración, el valor es \u0026ldquo;main\u0026rdquo;, por lo que se espera un ejecutable llamado \u0026ldquo;main\u0026rdquo; en tu directorio de trabajo actual. args: Es una lista de argumentos que se pasarán al programa cuando se lance. En tu caso, esta lista está vacía, por lo que no se pasarán argumentos. cwd: Especifica el directorio de trabajo actual cuando se inicia el programa. \u0026ldquo;${workspaceFolder}\u0026rdquo; es una variable que se refiere al directorio raíz de tu espacio de trabajo actual en VS Code. preLaunchTask: Es el nombre de una tarea definida en tasks.json que se ejecutará antes de que se lance el programa. Este es solo un ejemplo de configuración de depuración. La configuración exacta puede variar según el lenguaje de programación y el entorno de desarrollo específicos que estés utilizando.\nDepura tu código Zig: Establece puntos de interrupción en tu código Zig haciendo clic en el margen izquierdo junto a los números de línea. Presiona F5 para iniciar la depuración. El depurador se detendrá en tus puntos de interrupción, lo que te permitirá inspeccionar variables, avanzar paso a paso en tu código y utilizar otras funciones de depuración. ¡Eso es todo! Ahora has configurado Visual Studio Code para el desarrollo en Zig, incluyendo la ejecución, asistencia y depuración de tu código. 🎉\n¿Qué más? 🌟 Con tu flamante entorno de desarrollo Zig, estás listo para explorar temas avanzados de Zig y crear proyectos asombrosos. ¡Mantente atento a más publicaciones en el blog sobre conceptos avanzados de Zig!\n¡Sigamos explorando el mundo de Zig juntos! 👩‍💻👨‍💻🎨\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/configura-visual-studio-code-para-programar-en-zig/","summary":"¡Saludos, entusiastas de Zig! 👋 Es el momento de configurar un entorno de desarrollo cómodo para mejorar tu experiencia de programación en Zig. En esta publicación, te guiaré para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo edición de código, ejecución y depuración. ¡Sumérgete en el tema! 🚀\nConfigurando Visual Studio Code para el desarrollo en Zig 🛠️ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:","title":"Configura Visual Studio Code para programar en Zig 🎨"},{"content":"¡Hola, entusiastas de Zig! 👋 En la publicación anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas más avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicación, te guiaré en la instalación de Zig en Linux, Windows y macOS. ¡Comencemos! 🚀\nInstalando Zig en Linux 🐧 ⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyéndolo desde el código fuente.\nPaquetes precompilados: Descarga el paquete apropiado para tu distribución de Linux desde la página oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nConstruir desde el código fuente: Si prefieres construir Zig desde el código fuente, sigue estos pasos:\nInstala las dependencias necesarias: build-essential, cmake y git. Clona el repositorio de Zig: git clone https://github.com/ziglang/zig.git Cambia al directorio clonado: cd zig Crea un directorio de construcción: mkdir build \u0026amp;\u0026amp; cd build Ejecuta CMake para configurar la construcción: cmake .. Construye Zig: make Agrega el binario zig a tu PATH. Una forma alternativa es usar snap: snap install --edge zig --classic\nInstalando Zig en Windows 💻 Para usuarios de Windows, puedes instalar Zig utilizando los paquetes precompilados o el administrador de paquetes Scoop.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la página oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nScoop: Si tienes Scoop instalado, puedes instalar Zig ejecutando: scoop install zig\nInstalando Zig en macOS 🍏 Para usuarios de macOS, puedes instalar Zig utilizando los paquetes precompilados, Homebrew o MacPorts.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la página oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nHomebrew: Si tienes Homebrew instalado, puedes instalar Zig ejecutando: brew install zig\nMacPorts: Si tienes MacPorts instalado, puedes instalar Zig ejecutando: sudo port install zig\n¡Listo! Ahora deberías tener Zig instalado en tu sistema Linux, Windows o macOS. 🎉\n¿Qué más? 🌟 Con Zig instalado, estás listo para explorar temas más avanzados y aprovechar todo el potencial de este emocionante lenguaje.\n¡Ánimo programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/instalando-zig-en-linux-windows-y-macos/","summary":"¡Hola, entusiastas de Zig! 👋 En la publicación anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas más avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicación, te guiaré en la instalación de Zig en Linux, Windows y macOS. ¡Comencemos! 🚀\nInstalando Zig en Linux 🐧 ⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyéndolo desde el código fuente.","title":"Instalando Zig en Linux, Windows y macOS 🌍"},{"content":"¡Bienvenido al emocionante mundo de Zig! 🚀 Si estás buscando un lenguaje de programación que combine eficiencia, seguridad y un enfoque en el rendimiento, ¡has llegado al lugar correcto!\n¿Por qué Zig? 🎯 Una de las primeras cosas que notarás al explorar Zig es su enfoque en la seguridad y la prevención de errores. El compilador de Zig es estricto y te ayudará a detectar problemas en tiempo de compilación antes de que se conviertan en pesadillas en tiempo de ejecución. Esto no solo te brinda una mayor confianza en la calidad de tu código, sino que también te enseña buenas prácticas para evitar errores comunes.\nPero Zig no se detiene solo en la seguridad. Si te apasiona la programación de alto rendimiento y quieres escribir código que aproveche al máximo los recursos del sistema, Zig es el lenguaje adecuado para ti. Su sintaxis limpia y elegante te permite escribir código eficiente y optimizado sin sacrificar la legibilidad.\nAdemás, aprender Zig te brinda la oportunidad de adentrarte en el mundo de la programación de bajo nivel. Con Zig, puedes acceder directamente a la memoria y tener un control preciso sobre los recursos del sistema. Esto es especialmente útil si estás interesado en desarrollar aplicaciones de sistemas embebidos, controladores de dispositivos o soluciones de bajo nivel.\nZig también es una excelente opción para aquellos que están aprendiendo a programar. A través de Zig, puedes adquirir una comprensión sólida de los conceptos fundamentales de la programación, como el control de flujo, las estructuras de datos y los algoritmos. Al mismo tiempo, ampliarás tu perspectiva sobre la programación y desarrollarás habilidades valiosas para el futuro.\nNo te voy a engañar: Zig a veces muerde 😬, pero eso es bueno. Es un lenguage en plena creación y evoluciona muy rápidamente con cambios incompatibles y bugs. Además su determinado enfoque en la seguridad te obliga a ser consciente de muchos aspectos que en otros lenguages simplemente se ignoran (el precio se paga después). Pero no temas programador, ¡todo eso te hará mas fuerte!.💪\n¡Hola, mundo! 👋 Como en cualquier lenguaje, el primer paso es escribir un clásico \u0026ldquo;Hola, mundo\u0026rdquo; en Zig para ver qué pinta tiene y qué sensaciones te produce:\n⚠️ ¡Atención, programador! Este post utiliza la versión dev 0.11.0 de Zig\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;¡Hola, mundo!\\n\u0026#34;,.{}); } Es muy poco código pero ya se pueden observar algunas características del lenguaje Zig:\nEnfoque en la seguridad: El uso de la declaración try para manejar errores de manera explícita demuestra la preocupación por la seguridad y la prevención de errores en Zig.\nSintaxis limpia y legible: La sintaxis del programa es clara y fácil de entender, lo que facilita la lectura y escritura de código en Zig.\nManejo explícito de recursos: Al obtener el escritor de salida estándar a través de getStdOut(), Zig enfatiza el manejo explícito de recursos, permitiendo un control más preciso y seguro.\nOrientación a bajo nivel: Zig permite acceder directamente a la memoria y proporciona un mayor control sobre los recursos del sistema, lo que es útil en situaciones de programación de bajo nivel.\nEnfoque en el rendimiento: Zig está diseñado para ofrecer un rendimiento excepcional, lo que se refleja en la eficiencia del programa \u0026ldquo;Hello, World\u0026rdquo;.\nEstas cualidades son solo una pequeña muestra de las fortalezas de Zig como lenguaje de programación. A medida que te adentres en Zig, descubrirás muchas más ventajas que te ayudarán a desarrollar software eficiente y confiable.\nOtro ejemplo, un poco más completo, tiene esta pinta:\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { // Prints to stderr (it\u0026#39;s a shortcut based on `std.io.getStdErr()`) std.debug.print(\u0026#34;All your {s} are belong to us.\\n\u0026#34;, .{\u0026#34;codebase\u0026#34;}); // stdout is for the actual output of your application, for example if you // are implementing gzip, then only the compressed bytes should be sent to // stdout, not any debugging messages. const stdout_file = std.io.getStdOut().writer(); var bw = std.io.bufferedWriter(stdout_file); const stdout = bw.writer(); try stdout.print(\u0026#34;Run `zig build test` to run the tests.\\n\u0026#34;, .{}); try bw.flush(); // don\u0026#39;t forget to flush! } test \u0026#34;simple test\u0026#34; { var list = std.ArrayList(i32).init(std.testing.allocator); defer list.deinit(); // try commenting this out and see if zig detects the memory leak! try list.append(42); try std.testing.expectEqual(@as(i32, 42), list.pop()); } Me gusta, ¿Cómo aprendo? 📚💡 La documentación oficial de Zig es un excelente punto de partida. Puedes acceder a ella en el sitio web oficial de Zig y encontrarás una guía detallada, ejemplos de código, tutoriales y una descripción completa de la biblioteca estándar. La documentación oficial es constantemente actualizada y es una fuente confiable para comprender la sintaxis, las características del lenguaje y las mejores prácticas. Recuerda, consulta siempre la documentación de la versión de Zig que estés utilizando, porque puede variar mucho de una a otra.\nEl repositorio oficial de Zig en GitHub es una fuente invaluable de código fuente abierto en Zig. Puedes explorar proyectos de la comunidad, estudiar el código existente y aprender de ejemplos prácticos. También puedes contribuir a proyectos existentes o incluso iniciar tus propios proyectos en Zig.\nAdemás de GitHub, el subreddit de Zig y el canal de Discord oficial de Zig son excelentes lugares para conectarte con otros programadores de Zig, hacer preguntas, compartir conocimientos y obtener ayuda. Estos espacios de la comunidad están llenos de personas amigables y conocedoras que están dispuestas a ayudarte en tu viaje de aprendizaje en Zig.\nRecuerda que la práctica es fundamental para dominar cualquier lenguaje de programación. A medida que adquieras conocimientos, te recomiendo implementar proyectos pequeños y desafiantes por tu cuenta. Esto te permitirá aplicar lo que has aprendido, experimentar con difer\nY por supuesto ¡sigue este blog!. Te llevaré a un emocionante viaje a través del mundo de Zig. Compartiré tutoriales, consejos útiles, trucos y experiencias personales mientras exploramos juntos las maravillas y desafíos de este increíble lenguaje de programación. Desde los conceptos básicos hasta técnicas avanzadas, encontrarás contenido fresco y relevante para mejorar tus habilidades en Zig.\nAhora empieza todo ¡No te pierdas ninguno de los nuevos artículos de \u0026ldquo;Zig-zagueando\u0026rdquo;! Puedes suscribirte al blog mediante el clásico y eficiente RSS 📰 para recibir notificaciones cada vez que publique una nueva entrada. Además, te invito a participar en los comentarios, compartir tus propias experiencias y hacer preguntas sobre cualquier tema relacionado con Zig.\n¡Prepárate para disfrutar de un blog lleno de conocimientos, diversión y aventuras en Zig! ¡Nos vemos, valiente programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-un-lenguaje-de-programaci%C3%B3n-simple-y-potente/","summary":"¡Bienvenido al emocionante mundo de Zig! 🚀 Si estás buscando un lenguaje de programación que combine eficiencia, seguridad y un enfoque en el rendimiento, ¡has llegado al lugar correcto!\n¿Por qué Zig? 🎯 Una de las primeras cosas que notarás al explorar Zig es su enfoque en la seguridad y la prevención de errores. El compilador de Zig es estricto y te ayudará a detectar problemas en tiempo de compilación antes de que se conviertan en pesadillas en tiempo de ejecución.","title":"Zig: Un lenguaje de programación simple y potente 🚀"}]