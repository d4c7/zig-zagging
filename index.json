[{"content":"¡Hola de nuevo! 🙌 Esperamos que estés emocionado por continuar con el desarrollo de nuestro analizador de argumentos de línea de comandos, zig-argueando. En esta segunda parte, nos enfocaremos en crear la estructura básica de nuestra biblioteca. Empecemos.\nDiseñando la estructura de datos de los argumentos 📝 Necesitamos una estructura de datos que represente un argumento de línea de comandos y vamos a dedicarle un tiempo sustancial. Comprendo que puedes estar pensando, \u0026ldquo;¿Por qué debería pasar tanto tiempo pensando en estructuras de datos cuando hay tanto código que escribir?\u0026rdquo; Créeme, he estado allí. Pero a través de los años he aprendido que las estructuras de datos son fundamentales por varias razones:\nEficiencia: Las estructuras de datos correctas pueden hacer una gran diferencia en la eficiencia de tu aplicación. A veces, la diferencia entre un algoritmo O(n^2) y uno O(n log n) es simplemente la elección de la estructura de datos adecuada. Una decisión temprana y consciente puede evitar muchos problemas de rendimiento en el futuro.\nOrganización: El diseño de las estructuras de datos afecta a la organización de tu código. Una buena estructura de datos puede facilitar la lectura y la comprensión del código, haciendo que sea más fácil de mantener y extender.\nAbstracción: Las estructuras de datos nos permiten abstraer detalles complicados y centrarnos en problemas de alto nivel. Por ejemplo, no necesitamos saber exactamente cómo funciona una tabla hash para beneficiarnos de su capacidad para buscar elementos en tiempo constante.\nModelado de datos: Las estructuras de datos son una forma de modelar la realidad en nuestros programas. Un buen modelo de datos puede facilitar la resolución de problemas y hacer que nuestro código sea más flexible y adaptable a los cambios.\nPor eso es importante dedicarle tiempo desde el principio. No es solo por el hecho de \u0026ldquo;hacerlo bien\u0026rdquo; desde el comienzo. Es también por las consecuencias a largo plazo que pueden surgir si no se toma en cuenta. Las estructuras de datos mal elegidas pueden resultar en código lento, difícil de entender y de mantener, e incluso incorrecto.\nEs cierto que el desarrollo de software, después de todo, es un proceso iterativo. Puedes comenzar con una estructura de datos inicial simple que cumpla con los requisitos básicos de tu aplicación. A medida que tu aplicación crece y evoluciona, podrías encontrarte en la necesidad de revisar y ajustar estas estructuras para acomodar nuevas características o mejorar el rendimiento.\nSin embargo, quiero añadir una nota de precaución aquí: este camino puede ser realmente arduo. Cambiar la estructura de datos fundamental de un programa en funcionamiento puede ser un proceso complicado y propenso a errores. Podrías tener que reescribir grandes partes de tu código y hacer un extenso trabajo de pruebas para asegurarte de que todo sigue funcionando como se espera.\nNo quiero desalentarte de hacer iteraciones sobre tus estructuras de datos, pero sí es importante tener en cuenta que un poco de tiempo invertido en la planificación inicial puede ahorrar mucho tiempo y dolores de cabeza más adelante. Es un equilibrio delicado, ¿verdad? Pero esa es parte de la belleza y el desafío de nuestra profesión.\nEn Zig, utilizaremos struct para definir nuestros modelos de datos. En nuestro modelo, vamos a representar parámetros que pueden ser de tipo option o positional. Los argumentos de tipo option pueden tener un nombre corto y otro largo.\n⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nconst Param = struct { kind: Kind, tag: usize = 0, help: []const u8 = \u0026#34;\u0026#34;, check: ?*const Checks.Fn = null, }; const Kind = union(KindTag) { option: Option, positional: Positional, }; const Option = struct { format: Format = .flag, short: []const u8 = \u0026#34;\u0026#34;, long: []const u8 = \u0026#34;\u0026#34;, }; pub const Positional = struct { format: Format, }; Ambos tipos de parámetros definen un formato format que puede ser flag, single o multi representado parámetros tipo flag, que sólo pueden aparecer una vez o múltiples veces respectivamente. El formato, si no es flag, especifica un parser para convertir el argumento en un tipo de datos concreto. Además los parámetros pueden establecer una función personalizada de validación y definir el texto que aparecerá en la ayuda.\nconst Format = union(FormatTag) { flag: void, single: Single, multi: Multi, }; pub const Single = struct { parser: []const u8 = \u0026#34;STR\u0026#34;, default: ?[]const u8 = null, }; pub const Multi = struct { parser: []const u8 = \u0026#34;STR\u0026#34;, defaults: ?[]const []const u8 = null, min: usize = 1, max: usize = 1, }; Un parser permite convertir y validar un argumento en texto a un tipo concreto en Zig. Para ello definimos dos punteros funciones, uno para realizar el parsing en sí y el otro para validar el valor obtenido. Además podremos definir el texto que aparecerá en la ayuda.\nTodos los elementos anteriores forman parte de la estructura principal CommandLineParser que incluye la lista de parsers y paramétros, así como los texto de ayuda que incluyen cabecera, pie y descripción; y por supuesto las opciones de procesado.\nImplementando la función de análisis de argumentos 💡 Con la estructura básica en su lugar, es hora de implementar la función del CommandLineParser que analizará los argumentos. Esta función tomará la lista de argumentos proporcionada por el usuario (normalmente a través de std.process.args()) y llenará la estructura de datos Args.\npub fn parseArgs(comptime self: CommandLineParser, allocator: std.mem.Allocator) Args(self) { var it = try std.process.ArgIterator.initWithAllocator(allocator); defer it.deinit(); return self.parse(\u0026amp;it, allocator); } La función parseArgs recibe una lista de argumentos y procesa cada uno de ellos en orden. Si encuentra un argumento que no reconoce, o si se proporciona un valor para un argumento que no lo requiere, registra un problema. Si todo va bien, devuelve la estructura de datos Args llena con la información recopilada.\nLa estructura Args, que recibe el resultado del análisis de la línea de comandos, contiene:\nexe, que tiene el nombre del ejecutable args, que contiene una estructura con los nombres de las opciones y otro campo especial positionals con los argumentos posicionales problems, es una lista de problemas encontrados durante el análisis de los argumentos En este punto hay que hacer notar que todas las estructuras CommandLineParser, Args se han crean en tiempo de compilación. ¡Fantástico!\nUsando las estructuras 🛠 Zig-argueando propociona funciones con valores por defecto para inicializar las estructuras, de esta forma obtenemos muchas ventajas:\nPodemos mantener una interface más estable y simple al usuario. Podemos modificar estructuras internas sin que nuestros usuarios tengan que cambiar el código Es más sencillo inicializar las estructuras porque tienen valores predefinidos \u0026ldquo;válidos\u0026rdquo; Las estructuras no admiten campos que no sean relevantes para el objeto que se define Por ejemplo, para definir un parámetro que es un flag se proporciona la función flag, que admite una estructura que tiene preestablecidos sus campos:\npub const DefaultFlag = struct { short: []const u8 = \u0026#34;\u0026#34;, long: []const u8 = \u0026#34;\u0026#34;, help: []const u8 = \u0026#34;\u0026#34;, }; pub fn flag(comptime opts: DefaultFlag) Param { return Param{ .kind = .{ .option = .{ .short = opts.short, .long = opts.long, .format = .flag, } }, .help = opts.help, }; } Es muy fácil ahora definir un parámetro tipo flag que tenga como nombre largo --verbose y corto -v, con su correspondiente texto de ayuda:\nflag(.{ .long = \u0026#34;verbose\u0026#34;, .short = \u0026#34;v\u0026#34;, .help = \u0026#34;Enable verbose output.\u0026#34; }), Así proporcionamos funciones para definir parámetros flag, flagHelp, option, multiOption, singlePositional y multiPositional, y quién sabe si alguno más en el futuro.\nEsto permite definir los analizadores de una manera muy intuitiva a nuestro usuarios. En muchas ocasiones, la simplicidad para los usuarios es nuestra complejidad:\nconst clp = comptime Argueando.CommandLineParser.init(.{ .header= \\\\ \\ | \\\\ _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ \\\\ ___ \\ | ( | | | __/ ( | | | ( | ( | \\\\_/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ \\\\ |___/ ,.params = \u0026amp;[_]Argueando.Param{ flagHelp(.{ .long = \u0026#34;help\u0026#34;, .short = \u0026#34;h\u0026#34;, .help = \u0026#34;Shows this help.\u0026#34; }), flag(.{ .long = \u0026#34;version\u0026#34;, .help = \u0026#34;Output version information and exit.\u0026#34; }), flag(.{ .long = \u0026#34;verbose\u0026#34;, .short = \u0026#34;v\u0026#34;, .help = \u0026#34;Enable verbose output.\u0026#34; }), option(.{ .long = \u0026#34;port\u0026#34;, .short = \u0026#34;p\u0026#34;, .parser = \u0026#34;TCP_PORT\u0026#34;, .default = \u0026#34;1234\u0026#34;, .help = \u0026#34;Listening Port.\u0026#34; }), option(.{ .long = \u0026#34;host\u0026#34;, .short = \u0026#34;H\u0026#34;, .parser = \u0026#34;TCP_HOST\u0026#34;, .default = \u0026#34;localhost\u0026#34;, .help = \u0026#34;Host name\u0026#34; }), singlePositional(.{ .parser = \u0026#34;DIR\u0026#34;, .default = \u0026#34;.\u0026#34;, .check = \u0026amp;Check.Dir(.{ .mode = .read_only }).f }), }, // .desc = \u0026#34;This command starts an HTTP Server and serves static content from directory DIR.\u0026#34;, // .footer = \u0026#34;More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;.\u0026#34;, }); var s = clp.parseArgs(allocator); defer s.deinit(); if (s.helpRequested()) { try s.printHelp(std.io.getStdErr().writer()); return; } if (s.hasProblems()) { try s.printProblems(std.io.getStdErr().writer(), .AllProblems); return; } $ ./sample-argueando --help \\ | _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ ___ \\ | ( | | | __/ ( | | | ( | ( | _/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ |___/ Usage: sample-argueando [(-h|--help)] [--version] [(-v|--verbose)] [(-p|--port)=TCP_PORT] [(-H|--host)=TCP_HOST] [DIR] This command starts an HTTP Server and serves static content from directory DIR. -h, --help Shows this help. --version Output version information and exit. -v, --verbose Enable verbose output. -p, --port=TCP_PORT Listening Port. Default value: 1234 -H, --host=TCP_HOST Host name Default value: localhost TCP_PORT TCP port value between 0 and 65535. Use port 0 to dynamically assign a port Can use base prefix (0x,0o,0b). TCP_HOST TCP host name or IP. DIR Directory More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;. Conclusiones de la Segunda Parte ✨ Hemos definido los modelos de datos de nuestra biblioteca zig-argueando. Puedes ver código en desarrollo de la librería en GitHub, que iremos mejorando, analizando y explicando poco a poco. ¡Hasta la próxima! 👋\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/un-analizador-de-linea-de-comandos-en-zig-2/","summary":"¡Hola de nuevo! 🙌 Esperamos que estés emocionado por continuar con el desarrollo de nuestro analizador de argumentos de línea de comandos, zig-argueando. En esta segunda parte, nos enfocaremos en crear la estructura básica de nuestra biblioteca. Empecemos.\nDiseñando la estructura de datos de los argumentos 📝 Necesitamos una estructura de datos que represente un argumento de línea de comandos y vamos a dedicarle un tiempo sustancial. Comprendo que puedes estar pensando, \u0026ldquo;¿Por qué debería pasar tanto tiempo pensando en estructuras de datos cuando hay tanto código que escribir?","title":"Un analizador de línea de comandos en Zig 🔧 (Parte II)"},{"content":"¡Hola a todos! 👋 Hoy vamos a hablar de un tema muy interesante: cómo analizar los argumentos de la línea de comandos. ¡Prepárate para una profunda inmersión! 🌊🏊‍♂️\nIntroducción a los Argumentos de la Línea de Comandos 📝 Los argumentos de la línea de comandos son una forma común de especificar opciones para programas ejecutables. Son especialmente útiles para interactuar con tu programa de forma flexible y potente. En esencia, los argumentos de la línea de comandos son una lista de palabras que se pasan a un programa cuando se invoca. ¿Pero cómo se manejan en Zig? ¡Vamos a descubrirlo! 🕵️‍♀️\nArgumentos de la Línea de Comandos en Zig 🧮 En Zig, la sintaxis para los argumentos de la línea de comandos es bastante sencilla. Cuando se inicia un programa, los argumentos de la línea de comandos se pasan como una matriz de cadenas. Puedes recuperar argumentos de la línea de comandos usando la estructura std.process.ArgIterator e inicializándola con initWithAllocator(allocator: Allocator) si queremos abstraernos de la plataforma. Con este iterador podemos recorrer los argumentos, pero a menudo necesitamos un poco más de funcionalidad.\nvar it = try std.process.ArgIterator.initWithAllocator(allocator); defer it.deinit(); while (it.next()) |arg| { std.debug.print(\u0026#34;{s}\\n\u0026#34;, .{arg}); } También podemos usar std.process.ArgIterator.init() sin necesidad de allocator pero en la práctica la opción anterior es la más recomendable, teniendo además en cuenta que el uso de un parsing más sofisticado de los argumentos casi seguro requerirá de un asignador de memoria.\nPróximamente: Aprende sobre allocators en el artículo \u0026ldquo;Memoria en Zig\u0026rdquo;\nBibliotecas de análisis Es cuando necesitamos más funcionalidad cuando entran las bibliotecas de análisis como \u0026lsquo;zig-clap\u0026rsquo; o \u0026lsquo;zig-args\u0026rsquo;:\nPróximamente: Aprende sobre el uso de librerías en Zig en el artículo \u0026ldquo;Las librerías de Zig\u0026rdquo;\nzig-clap: Es una biblioteca simple y fácil de usar para el análisis de argumentos de línea de comando en Zig. Ofrece características como argumentos cortos y largos, soporte para pasar valores usando espacios y \u0026lsquo;=\u0026rsquo;, opciones que pueden ser especificadas múltiples veces, impresión y análisis de mensajes de ayuda a partir de especificaciones de parámetros. En esencia le pasamos una definición en forma de texto de cómo queremos parsear los argumentos y nos creará una estructura, en tiempo de compilación, para esa definición. Luego rellenaremos una instancia de la estructura con las opciones y argumentos pasados al programa.\nAprende todo sobre tiempo de compilación en \u0026ldquo;Zig comptime\u0026rdquo;\n⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nconst params = comptime clap.parseParamsComptime( \\\\-h, --help Display this help and exit. \\\\-n, --number \u0026lt;usize\u0026gt; An option parameter, which takes a value. \\\\-s, --string \u0026lt;str\u0026gt;... An option parameter which can be specified multiple times. \\\\\u0026lt;str\u0026gt;... \\\\ ); var diag = clap.Diagnostic{}; var res = clap.parse(clap.Help, \u0026amp;params, clap.parsers.default, .{ .diagnostic = \u0026amp;diag, }) catch |err| { diag.report(std.io.getStdErr().writer(), err) catch {}; return err; }; defer res.deinit(); if (res.args.help != 0) return clap.help(std.io.getStdErr().writer(), clap.Help, \u0026amp;params, .{}); if (res.args.number) |n| std.debug.print(\u0026#34;--number = {}\\n\u0026#34;, .{n}); for (res.args.string) |s| std.debug.print(\u0026#34;--string = {s}\\n\u0026#34;, .{s}); std.debug.print(\u0026#34;positional arguments:\\n\u0026#34;, .{}); for (res.positionals) |pos| { std.debug.print(\u0026#34;{s}\\n\u0026#34;, .{pos}); } En \u0026lsquo;zig-clap\u0026rsquo;, puedes manejar casos más complejos, como subcomandos o argumentos opcionales y definir tu propio parsing de argumentos con clap.parsers.default. 💡\nEs esencial manejar errores al analizar argumentos de la línea de comandos. En \u0026lsquo;zig-clap\u0026rsquo;, puedes usar la estructura Diagnostics para informar errores útiles. 🚑\nzig-args: Este es otro módulo de Zig para el análisis de argumentos de línea de comando. Proporciona funciones para analizar argumentos para una especificación dada y nuestro proceso actual, con opciones para manejar errores de análisis. También permite el uso de un método \u0026lsquo;Verb\u0026rsquo;, lo que significa que el primer argumento posicional se interpreta como un verbo que puede ser considerado un subcomando que proporciona más opciones específicas. A diferencia de clap, definimos las opciones y argumentos en una estructura que se rellenará al analizar los argumentos.\nconst options = try argsParser.parseForCurrentProcess(struct { // This declares long options for double hyphen output: ?[]const u8 = null, @\u0026#34;with-offset\u0026#34;: bool = false, @\u0026#34;with-hexdump\u0026#34;: bool = false, @\u0026#34;intermix-source\u0026#34;: bool = false, numberOfBytes: ?i32 = null, signed_number: ?i64 = null, unsigned_number: ?u64 = null, mode: enum { default, special, slow, fast } = .default, // This declares short-hand options for single hyphen pub const shorthands = .{ .S = \u0026#34;intermix-source\u0026#34;, .b = \u0026#34;with-hexdump\u0026#34;, .O = \u0026#34;with-offset\u0026#34;, .o = \u0026#34;output\u0026#34;, }; }, allocator, .print); defer options.deinit(); if (options.executable_name) |exe| { std.debug.print(\u0026#34;executable name: {s}\\n\u0026#34;, .{exe}); } std.debug.print(\u0026#34;parsed options:\\n\u0026#34;, .{}); inline for (std.meta.fields(@TypeOf(options.options))) |fld| { std.debug.print(\u0026#34;\\t{s} = {any}\\n\u0026#34;, .{ fld.name, @field(options.options, fld.name), }); } std.debug.print(\u0026#34;parsed positionals:\\n\u0026#34;, .{}); for (options.positionals) |arg| { std.debug.print(\u0026#34;\\t\u0026#39;{s}\u0026#39;\\n\u0026#34;, .{arg}); } Nuestro propio analizador 🤓 Usar una biblioteca probada es lo que uno debe hacer normalmente y no inventar la rueda a la primera de cambio. Pero estamos aquí para aprender y divertirnos con Zig, así que no vamos a dejar pasar la oportunidad de implementar nuestro propio analizador de argumentos de línea de comando. ¡Sí, lo has oído bien! 🎉🎉.\nAprenderás una cantidad increíble en el proceso. Vas a entender mejor cómo funcionan las cosas bajo el capó, cómo los argumentos pasan de la línea de comandos a tu programa y cómo puedes manipularlos para hacer exactamente lo que quieres. ¡Es como tener superpoderes! 💪🚀 Así que, poneros cómodos, preparaos una taza de vuestro café o te favorito ☕ y ¡vamos a ello, creemos nuestra propia biblioteca de análisis de argumentos de línea de comando: zig-argueando! 🎯\nConvenciones POSIX Nuestro analizado implementará, en general, las convenciones recomendadas por POSIX para los argumentos de la línea de comandos:\nLos argumentos son opciones cortas si comienzan con un delimitador de guión (-) más un caracter alfanuméricos individuales u opviones largar si empiezan con doble guión (--) con un nombre largo. Varias opciones cortas pueden seguir a un delimitador de guión en un solo token si las opciones no toman argumentos. Por lo tanto, -abc es equivalente a -a -b -c. La última opción si podrá tener argumento. Algunas opciones requieren un argumento. Por ejemplo, la opción -o del comando ld requiere un argumento, un nombre de archivo de salida. Las opciones normalmente preceden a otros argumentos que no son opciones y que se llaman posicionales. Los argumentos de las opciones pueden ir en el mismo token si la opción y su argumento está separado por un separador. Por ejemplo, -a=foo o --name=value en lugar de -a foo o --name value Un argumento que es exactamente doble guión (--) indica que a partir de ese argumentos todos los demás son posicionales. Un argumento que es exactamente un guión (-) se tratará como posicional. Suele indicar entrada o salida estandar. Las opciones se pueden suministrar en cualquier orden. Pero nos saldremos un poco de las convenciones en estos aspectos, por otra parte discutibles:\nUna opción y su argumento pueden aparecer o no como tokens separados. En otras palabras, el espacio en blanco que los separa es opcional. Por lo tanto, -o foo y -ofoo son equivalentes. Pero nuestro analizador no va a permitir esto ya que puede dar lugar a ambigüedades. Los nombres de las opciones deben escribirse completamente y daremos la opción como desconocida si es parcial aunque no haya conflicto. Si la opción es --host no podrá escribirse como --hos, ni --ho, ni --h. Las opciones pueden aparecer varias veces pero sólo si son opciones que lo permiten explícitamente o tienen el mismo valor. Nada de la última opción gana, buff. Necesitamos un plan Estos son una serie de tareas iniciales para diseñar un parser de línea de comandos en Zig:\nDiseñar la estructura de datos de los argumentos\nDefine una estructura de datos que represente un argumento de línea de comandos. Esta estructura debe contener información como el nombre corto de la opción (si existe), el nombre largo (si existe), si la opción necesita un valor, y cualquier valor predeterminado o proporcionado por el usuario.\nImplementar la función de análisis de argumentos\nEsta función debería tomar la lista de argumentos proporcionados por el usuario (generalmente a través de std.process.args()) y llenar la estructura de datos definida anteriormente. Debe ser capaz de manejar tanto argumentos cortos (-a) como largos (--arg), y debe manejar correctamente los argumentos que requieren valores (-o value o -o value o --option=value). También debe ser capaz de manejar el caso especial de --, que indica el final de los argumentos.\nImplementar el manejo de errores\nSi el usuario proporciona un argumento que no se reconoce, o si se proporciona un valor para un argumento que no requiere uno, el parser debe ser capaz de manejar esto de manera elegante. Esto puede incluir la generación de mensajes de error útiles.\nImplementar funciones de ayuda\nProporcionar funciones que generen automáticamente mensajes de ayuda basados en las estructuras de argumentos definidas. Esto puede incluir una descripción del comando y de cada argumento, si se requiere un valor, y cualquier valor predeterminado.\nPruebas\nProbaremos completamente el parser de línea de comandos. Esto incluirá pruebas para argumentos cortos y largos, argumentos con y sin valores, el indicador --, y el manejo de errores.\nFin de la primera parte 🌟 No te pierdas las siguientes partes donde comenzaremos a implementar el analizador explicando paso a paso lo que hacemos. ¡Nos vemos! Un ejemplo de lo que vamos a programar:\nconst clp = comptime Argueando.CommandLineParser.init(.{ .header= \\\\ \\ | \\\\ _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ \\\\ ___ \\ | ( | | | __/ ( | | | ( | ( | \\\\_/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ \\\\ |___/ ,.params = \u0026amp;[_]Argueando.Param{ flagHelp(.{ .long = \u0026#34;help\u0026#34;, .short = \u0026#34;h\u0026#34;, .help = \u0026#34;Shows this help.\u0026#34; }), flag(.{ .long = \u0026#34;version\u0026#34;, .help = \u0026#34;Output version information and exit.\u0026#34; }), flag(.{ .long = \u0026#34;verbose\u0026#34;, .short = \u0026#34;v\u0026#34;, .help = \u0026#34;Enable verbose output.\u0026#34; }), option(.{ .long = \u0026#34;port\u0026#34;, .short = \u0026#34;p\u0026#34;, .parser = \u0026#34;TCP_PORT\u0026#34;, .default = \u0026#34;1234\u0026#34;, .help = \u0026#34;Listening Port.\u0026#34; }), option(.{ .long = \u0026#34;host\u0026#34;, .short = \u0026#34;H\u0026#34;, .parser = \u0026#34;TCP_HOST\u0026#34;, .default = \u0026#34;localhost\u0026#34;, .help = \u0026#34;Host name\u0026#34; }), singlePositional(.{ .parser = \u0026#34;DIR\u0026#34;, .default = \u0026#34;.\u0026#34;, .check = \u0026amp;Check.Dir(.{ .mode = .read_only }).f }), }, // .desc = \u0026#34;This command starts an HTTP Server and serves static content from directory DIR.\u0026#34;, // .footer = \u0026#34;More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;.\u0026#34;, }); var s = clp.parseArgs(allocator); defer s.deinit(); if (s.helpRequested()) { try s.printHelp(std.io.getStdErr().writer()); return; } if (s.hasProblems()) { try s.printProblems(std.io.getStdErr().writer(), .AllProblems); return; } \\ | _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ ___ \\ | ( | | | __/ ( | | | ( | ( | _/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ |___/ Usage: sample-argueando [(-h|--help)] [--version] [(-v|--verbose)] [(-p|--port)=TCP_PORT] [(-H|--host)=TCP_HOST] [DIR] This command starts an HTTP Server and serves static content from directory DIR. -h, --help Shows this help. --version Output version information and exit. -v, --verbose Enable verbose output. -p, --port=TCP_PORT Listening Port. Default value: 1234 -H, --host=TCP_HOST Host name Default value: localhost TCP_PORT TCP port value between 0 and 65535. Use port 0 to dynamically assign a port Can use base prefix (0x,0o,0b). TCP_HOST TCP host name or IP. DIR Directory More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;. ","permalink":"https://d4c7.github.io/zig-zagueando/posts/un-analizador-de-linea-de-comandos-en-zig-1/","summary":"¡Hola a todos! 👋 Hoy vamos a hablar de un tema muy interesante: cómo analizar los argumentos de la línea de comandos. ¡Prepárate para una profunda inmersión! 🌊🏊‍♂️\nIntroducción a los Argumentos de la Línea de Comandos 📝 Los argumentos de la línea de comandos son una forma común de especificar opciones para programas ejecutables. Son especialmente útiles para interactuar con tu programa de forma flexible y potente. En esencia, los argumentos de la línea de comandos son una lista de palabras que se pasan a un programa cuando se invoca.","title":"Un analizador de línea de comandos en Zig 🔧 (Parte I)"},{"content":"¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮\n¿Qué es comptime? El término comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al español, sería \u0026ldquo;Tiempo de Compilación\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante. En Zig, puedes decidir qué parte de tu código se ejecutará en tiempo de compilación y cuál en tiempo de ejecución. 🕓\nPrincipales ventajas de comptime Quizás te estés preguntando, ¿por qué querríamos hacer cálculos en tiempo de compilación?\nFlexibilidad: Gracias a comptime, puedes generar código en tiempo de compilación de forma dinámica. Esto significa que puedes decidir cómo se comportará tu programa en función de las condiciones existentes durante la compilación. 😏\nEficiencia: Al mover ciertas operaciones al tiempo de compilación, puedes mejorar significativamente la eficiencia de tu código en tiempo de ejecución. En lugar de calcular algo cada vez que se ejecuta tu programa, lo calculas una vez durante la compilación y ya está. Es como preparar toda la comida de antemano para que, cuando lleguen los invitados, ¡solo tengas que encender el fuego! 🍳⏲️\nSeguridad: comptime puede ayudarte a detectar errores en tiempo de compilación en lugar de en tiempo de ejecución. Cuanto antes detectes los errores, más segura será tu aplicación. 💪\nAbstracción sin costo: A diferencia de otros lenguajes que pagan un precio por abstracciones de alto nivel (con rendimiento más lento o más memoria usada), Zig permite abstracciones sin costos adicionales, gracias al poder de comptime.🎉\nEjemplo básico de uso de comptime En su forma más básica comptime es la forma en la que una variable se calcula en tiempo de compilación para convertirse en una constante en tiempo de ejecución. Aquí hay un pequeño fragmento de código para que te hagas una idea de cómo se utiliza comptime.\n⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nfn suma() u64 { var r: u64 = 0; for (1..100) |i| { r += i; } return r; } pub fn main() void { var s = comptime suma(); std.debug.print(\u0026#34;{}\u0026#34;, .{s}); sumaB(); } Cuando compiles este código, verás que suma se calcula en tiempo de compilación y su resultado es simplemente una constante. En tiempo de ejecución, este bloque comptime no tiene ningún efecto.\nexample.main: push rbp mov rbp, rsp sub rsp, 16 mov qword ptr [rbp - 8], 4950 call debug.print__anon_3471 add rsp, 16 pop rbp ret Explicación del código Este código es esamblador de arquitectura x86-64 (o AMD64):\npush rbp: Guarda el valor actual del puntero base del marco (frame base pointer) en la pila. Esto se hace generalmente al inicio de una función para preservar el valor actual de rbp para poder restaurarlo más tarde.\nmov rbp, rsp: Establece el puntero base del marco al valor actual del puntero de la pila (stack pointer). Esto se hace para que la función tenga un punto de referencia fijo para acceder a las variables locales y los argumentos.\nsub rsp, 16: Reserva 16 bytes en la pila para las variables locales de esta función, moviendo el puntero de la pila hacia abajo (en la mayoría de las arquitecturas, la pila crece hacia abajo en la memoria).\nmov qword ptr [rbp - 8], 4950: Guarda el valor 4950 en la ubicación de la pila 8 bytes por debajo del puntero base del marco. Probablemente esto está inicializando una variable local.\ncall debug.print__anon_3471: Llama a la función debug.print__anon_3471. Esta función pinta el valor de la variable local que acabamos de inicializar.\nadd rsp, 16: Restablece el puntero de la pila a su posición antes de que reserváramos espacio para las variables locales. Esto efectivamente \u0026ldquo;libera\u0026rdquo; ese espacio de la pila.\npop rbp: Restaura el puntero base del marco a su valor antes de la llamada a la función, esencialmente limpiando después de que la función haya terminado.\nret: Retorna de la función, saltando de vuelta a la dirección de retorno almacenada en la pila por la instrucción call que llamó a esta función.\nOtra forma de asignar un cálculo en comptime a una variable o constate es usando break :etiqueta valor en un bloque:\nvar s = comptime e: { var r: u64 = 0; for (1..100) |i| { r += i; } break :e r; }; ¿Pero que pasaría si nos encontramos un bucle demasiado largo en tiempo de compilación? Comptime tiene un limitador de la cantidad de ramificaciones que se pueden evaluar en tiempo de compilación, lo cual es útil para prevenir bucles infinitos y otros problemas que pueden consumir una cantidad excesiva de recursos durante la compilación. Se puede cambiar el límite con la función @setEvalBranchQuota(), que por defecto es 1000.\nConviene recordarlo si nos encontramos con un error similar a este compilando:\nerror: evaluation exceeded 1000 backwards branches note: use @setEvalBranchQuota() to raise the branch limit from 1000 Comparación con tiempo de ejecución Entonces, ¿cómo se compara comptime con los cálculos en tiempo de ejecución tradicionales? Cuando un programa Zig se está ejecutando, a menudo hay decisiones que tomar, como elegir qué ramas de código ejecutar. Normalmente, esto ocurre en tiempo de ejecución, pero con comptime, estas decisiones se pueden tomar en tiempo de compilación. Es como resolver la mayor parte del rompecabezas antes de que empiece a correr el reloj. ⏳🧩\nAplicaciones prácticas de comptime De acuerdo, la teoría es buena, ¡pero veamos comptime en acción! Te guiaré a través de algunos ejemplos prácticos donde comptime puede brillar, como cuando trabajas con metaprogramación o programación genérica. ¡Aquí es donde comptime pasa de ser simplemente \u0026lsquo;genial\u0026rsquo; a \u0026lsquo;absolutamente fantástico\u0026rsquo;! 🌟🔧\nQué es @compileLog En Zig, @compileLog es una función incorporada que te permite registrar mensajes durante el tiempo de compilación. Es una herramienta maravillosa para la depuración o para entender lo que está sucediendo en tiempo de compilación. Aquí tienes un ejemplo rápido:\ncomptime { const a = 5; @compileLog(\u0026#34;Valor de a en tiempo de compilación: \u0026#34;, a); } En el código anterior, @compileLog imprimirá el mensaje \u0026ldquo;Valor de a en tiempo de compilación: 5\u0026rdquo; durante el proceso de compilación. ¡Esto puede ser muy útil cuando estás lidiando con expresiones o funciones comptime complejas! 🤔💭\nHay que hace notar que, a día de hoy, la compilación fallará si se ha ejecutado cualquier @compileLog. La razón es evitar que las librerías polucionen de mensajes la compilación de un programa.\nQué es @compileError @compileError es otra función incorporada en Zig que se utiliza para lanzar un error en tiempo de compilación. Esto es súper útil para asegurar ciertas condiciones durante el tiempo de compilación y detener la compilación si no se cumplen. Así es cómo puedes usarlo:\ncomptime { if (!std.builtin.target.isWasm()) { @compileError(\u0026#34;WasmPageAllocator is only available for wasm32 arch\u0026#34;); } } En este ejemplo, si la arquitectura en la se está intentando compilar el programa no es la adecuada se lanzará un error de compilación con @compileError 💥🛑\nComptime para metaprogramación La metaprogramación se refiere a la capacidad de un programa para tratar su código como datos y manipularlo. En Zig, comptime proporciona una forma poderosa de lograr la metaprogramación. Por ejemplo, puedes generar funciones especializadas para diferentes tipos:\nfn createAdder(comptime T: type) type { return struct { fn add(a: T, b: T) T { return a + b; } }; } const IntAdder = createAdder(i32); const FloatAdder = createAdder(f32); var i = IntAdder.add(10, 20); var f = FloatAdder.add(1.0, 2.0); En el código anterior, estamos generando dos estructuras en tiempo de compilación: IntAdder y FloatAdder. Cada una tiene una función add, pero trabajan con tipos diferentes (i32 y f32). ¡Esto es solo la punta del iceberg cuando se trata de metaprogramación con comptime! 🧠🔮\nPor ejemplo, podemos crear estructuras completas en tiempo de compilación:\nfn makeType(comptime n: usize) type { var fields: [n]std.builtin.Type.StructField = undefined; inline for (0..n) |v| { const default_value: u32 = v; fields[v] = .{ .name = std.fmt.comptimePrint(\u0026#34;field{}\u0026#34;, .{v}), .type = @TypeOf(default_value), .default_value = @ptrCast(*const anyopaque, \u0026amp;default_value), .is_comptime = false, .alignment = @alignOf(@TypeOf(default_value)), }; } return @Type(.{ .Struct = .{ .layout = .Auto, .fields = fields[0..], .decls = \u0026amp;.{}, .is_tuple = false, } }); } const T2 = comptime makeType(2); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T2{}}); const T3 = comptime makeType(3); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T3{}}); sample.makeType(2){ .field0 = 0, .field1 = 1 } sample.makeType(3){ .field0 = 0, .field1 = 1, .field2 = 2 } Detalles importantes en este código:\nLa matriz fields tiene un tamaño fijo determinado en tiempo de compilación.\nEl bucle inline for itera sobre el rango 0..n. Es por tanto un bucle que se desenrrolla. ¿Crees que es obligatorio este desenrollado? ¿En necesario?\nComptime y asignación de memoria Lo ideal sería poder utilizar todas las estructuras de datos disponibles en Zig para poder ejecutar cálculos en tiempo de compilación. Aunque de momento no existe en la librería estándar un asignador de memoria (allocator) de Zig en para tiempo de compilación, podemos implementar el nuestro propio con facilidad. Así, con un poco de cuidado, podremos usar en comptime, de forma auxilia,r estructuras como std.ArrayList:\nfn makeSlice(allocator: std.mem.Allocator) ![]u8 { var list = std.ArrayList(u8).init(allocator); defer list.deinit(); try list.append(1); try list.append(2); return try list.toOwnedSlice(); } const array = comptime e: { var buffer: [1024]u8 = undefined; var cfba = ComptimeFixedBufferAllocator.init(\u0026amp;buffer); const v = makeSlice(cfba.allocator()) catch { @compileError(\u0026#34;allocation error, increase fixed buffer size\u0026#34;); }; break :e v[0..].*; }; std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{array}); ⚠️ ¡Atención, programador! Ten en cuenta que siempre debes transformar los slices en matrices constantes para evitar incrustar todo el buffer de memoria del allocator en el programa compilado final, fíjate en break :e v[0..].*;. Esto es importante.\nVer código de ejemplo de un allocator para comptime Es básicamente una copia de std.heap.FixedBufferAllocator. Por cierto, ¿por qué crees que no podemos usarlo en comptime?:\npub const ComptimeFixedBufferAllocator = struct { end_index: usize, buffer: []u8, pub fn init(buffer: []u8) ComptimeFixedBufferAllocator { return ComptimeFixedBufferAllocator{ .buffer = buffer, .end_index = 0, }; } pub fn allocator(self: *ComptimeFixedBufferAllocator) std.mem.Allocator { return .{ .ptr = self, .vtable = \u0026amp;.{ .alloc = alloc, .resize = resize, .free = free, }, }; } pub fn isLastAllocation(self: *ComptimeFixedBufferAllocator, buf: []u8) bool { return buf.ptr + buf.len == self.buffer.ptr + self.end_index; } fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = ra; const ptr_align = @as(usize, 1) \u0026lt;\u0026lt; @intCast(std.mem.Allocator.Log2Align, log2_ptr_align); const adjust_off = std.mem.alignPointerOffset(self.buffer.ptr + self.end_index, ptr_align) orelse return null; const adjusted_index = self.end_index + adjust_off; const new_end_index = adjusted_index + n; if (new_end_index \u0026gt; self.buffer.len) return null; self.end_index = new_end_index; return self.buffer.ptr + adjusted_index; } fn resize( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, new_size: usize, return_address: usize, ) bool { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (!self.isLastAllocation(buf)) { if (new_size \u0026gt; buf.len) return false; return true; } if (new_size \u0026lt;= buf.len) { const sub = buf.len - new_size; self.end_index -= sub; return true; } const add = new_size - buf.len; if (add + self.end_index \u0026gt; self.buffer.len) return false; self.end_index += add; return true; } fn free( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, return_address: usize, ) void { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (self.isLastAllocation(buf)) { self.end_index -= buf.len; } } pub fn reset(self: *ComptimeFixedBufferAllocator) void { self.end_index = 0; } }; Recuerda que aunque comptime nos permite realizar algunos trucos poderosos, no es una solución milagrosa. Es simplemente otra herramienta en nuestro kit de herramientas Zig que, cuando se usa adecuadamente, puede conducir a un código más limpio, eficiente y robusto. ¡Pero como siempre, con un gran poder viene una gran responsabilidad! Así que usemos comptime sabiamente\u0026hellip;\nLimitaciones de comptime ️🕸️ Hay algunos posibles problemas al usar comptime de los que debes estar al tanto 😅. Los principales son:\nSin operaciones de I/O: Durante el tiempo de compilación, no puedes realizar ninguna operación de entrada/salida. Así es, no puedes leer archivos, escribir en la consola, comunicarte a través de la red, ¡nada! Recuerda, comptime opera en una máquina abstracta idealizada sin acceso al mundo exterior. 🌐🔒\nSin acceso a variables de entorno: De manera similar, comptime no tiene acceso a las variables de entorno en tiempo de ejecución. Esto incluye cosas como la hora del sistema, el identificador del proceso o las variables de entorno específicas del usuario. ¡Todo se trata del código, amigos! 🖥️🚫\nAsignación de memoria: Hablamos antes de cómo comptime gestiona la memoria y la falta de un allocator para comptime. Es importante recordar que comptime y el tiempo de ejecución son dos dominios diferentes. 🧙‍♂️🏰\n¡Y ya está, amigos!. Un profundo viaje al mundo mágico de comptime en Zig. Espero que hayas disfrutado nuestro recorrido y que ahora estés tan entusiasmado con comptime como yo. Recuerda, el aprendizaje es un proceso continuo, así que nunca dejes de explorar y experimentar con Zig. ¡Sigue codificando con pasión y creatividad! 🚀💻\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-comptime/","summary":"¡Hola a todos! 🙌 ¡Vamos a sumergirnos en uno de los conceptos más apasionantes y poderosos de Zig: el comptime! Esta característica, si no has oído hablar de ella, puede cambiar completamente tu perspectiva sobre cómo escribir código. 😮\n¿Qué es comptime? El término comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al español, sería \u0026ldquo;Tiempo de Compilación\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma más básica, cada vez que utilizas una constante.","title":"Zig comptime"},{"content":"¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). Prepárate para desbloquear el poder de Zig en el navegador! 🌐💪\n¿Qué es WebAssembly? 🧐 WebAssembly es un formato de instrucción binaria diseñado como un objetivo portable para la compilación de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar código en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.\n¿Por qué Zig con WebAssembly? 🤔 La simplicidad, eficiencia y robustez de Zig lo convierten en una excelente elección para el desarrollo de WebAssembly. La capacidad de Zig para compilar cruzadamente sin problemas es una enorme ventaja, y su fuerte enfoque en la seguridad es perfecto para el entorno protegido de la web.\nEmpezando con Zig y WebAssembly 🚀 Vamos a crear un simple programa Zig y compilarlo a WebAssembly.\nComienza escribiendo un simple programa Zig. Abre tu editor de código y crea un nuevo archivo llamado hello.zig: ⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nextern fn print(a: i32) void; export fn add(a: i32, b: i32) i32 { print(1234); return a + b; } Este código establece una interfaz entre Zig y JavaScript. La declaración extern fn print(a: i32) void; permite a Zig usar la función print de JavaScript, y export fn add(a: i32, b: i32) i32 { ... } proporciona una función que puede ser llamada desde JavaScript.\nPara compilar este código Zig a WebAssembly, añade un archivo build.zig const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const target = std.zig.CrossTarget{ .cpu_arch = .wasm32, .os_tag = .freestanding, .abi = .musl, }; const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = .ReleaseFast }); const lib = b.addSharedLibrary(.{ .name = \u0026#34;hello\u0026#34;, .root_source_file = .{ .path = \u0026#34;./hello.zig\u0026#34; }, .target = target, .optimize = optimize, }); lib.rdynamic = true; b.installArtifact(lib); } Vamos a verlo con detalle:\nconst std = @import(\u0026quot;std\u0026quot;);\nAquí estamos importando la biblioteca estándar de Zig (std). Esto nos da acceso a todas las funciones y utilidades proporcionadas por la biblioteca estándar. 📚🔍\npub fn build(b: *std.build.Builder) void {\nEn esta línea, definimos la función principal build para nuestro script de compilación, que recibe un puntero a una instancia de std.build.Builder. Este es nuestro guía para la aventura de la construcción de código. 🏗️🗺️\nconst target = std.zig.CrossTarget{...};\nAquí estamos creando un objetivo de compilación cruzada para WebAssembly con el tag del sistema operativo freestanding y la interfaz binaria de aplicación musl. Esta es la maleta que preparamos para nuestro viaje a WebAssembly Land. 🛄🎯\nconst optimize = b.standardOptimizeOption(...);\nAquí definimos las opciones de optimización. Estamos eligiendo la opción de optimización ReleaseFast, que es como decir \u0026ldquo;¡Vamos a correr como el viento, pero sin tropezar!\u0026rdquo; 🏃‍♂️💨\nconst lib = b.addSharedLibrary(...);\nEn este paso, le decimos a nuestro guía (el constructor b) que queremos construir una biblioteca compartida llamada hello a partir del archivo de origen hello.zig, con las opciones de objetivo y optimización que definimos anteriormente. Es como pedirle a nuestro guía que prepare los planes para construir un puente a WebAssembly Land. 🌉🛠️\nlib.rdynamic = true;\nLa opción rdynamic es absolutamente necesaria en Zig 0.11.0, ya que el linker de wasm integrado en Zig no exporta los símbolos definidos. La opción rdynamic sirve para enlazar dinamicamente librerías y es particularmente útil cuando quieres exportar símbolos desde un ejecutable. El uso de esta opción en el contexto de WebAssembly es una solución (workaround) a este problema.\nb.installArtifact(lib);\nFinalmente, le decimos a nuestro guía que instale la biblioteca que acabamos de construir. Esto coloca nuestra hermosa biblioteca hello en el lugar correcto para que otros puedan usarla. Es como colocar nuestro puente recién construido en el mapa para que todos puedan encontrarlo. 🗺️🌉\nPara construir el proyecto teclea el siguiente comando:\nzig build Tenemos nuestro módulo listo, ahora vamos por el HTML y Javascript. Creamos un archivo index.html: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Zig: ¡Hola WASM!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;Zig: ¡Hola WASM!\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;(¡Abre la consola!)\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;loader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Creamos un script de carga para cargar y ejecutar nuestro módulo WebAssembly. Creamos un nuevo archivo en el mismo directorio llamado loader.js: WebAssembly.instantiateStreaming(fetch(\u0026#39;zig-out/lib/hello.wasm\u0026#39;), { env: { print: function (x) { console.log(\u0026#34;Llamada desde zig:\u0026#34;, x); } } }).then(result =\u0026gt; { const add = result.instance.exports.add; console.log(\u0026#34;Llamada a Zig:\u0026#34;, add(3, 5)); }); Este código muestra cómo se puede cargar y ejecutar un módulo WebAssembly en un entorno de navegador. Para ello, se prepara una solicitud HTTP GET al archivo .wasm que se pasa a WebAssembly.instantiateStreaming para descargar, compilar y ejecutar el módulo.\nEl objeto de importación que se pasa a WebAssembly.instantiateStreaming representa el entorno del host. En este caso, proporcionamos una función de impresión que se puede llamar desde el módulo WebAssembly. Una vez que el módulo se ha instanciado correctamente, podemos acceder a las funciones exportadas y llamarlas como cualquier otra función de JavaScript.\nInicia cualquier servidor HTTP Debido a las políticas de CORS en la mayoría de los navegadores, es necesario servir nuestro módulo WebAssembly a través de un servidor HTTP. Puedes hacerlo fácilmente con Python ejecutando el comando:\n$ python -m SimpleHTTPServer 8001 Navega a http://localhost:8001 en tu navegador, y estarás listo para ver el funcionamiento de tu programa.\n¡Y eso es todo! Acabas de escribir tu primer programa Zig para WebAssembly. 🎉\nQuiero más 🌟 Atentos a nuestros próximos posts, donde iremos un paso más allá y construiremos juntos y poco a poco un clásico: ¡El juego ese de bloques que caen de arriba! No solo será una oportunidad para divertirnos mientras programamos, sino también una forma efectiva de aprender y profundizar en nuestros conocimientos sobre WebAssembly, Zig, juegos, IA, algoritmos, estructuras de datos, usabilidad y muchos otros.\n¡Pruébalo un poco para ir abriendo el apetito!\nEspero que esta publicación te haya proporcionado una sólida introducción a WebAssembly y Zig. ¡Nos vemos en la próxima!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/webassembly-y-zig-comenzando/","summary":"¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). Prepárate para desbloquear el poder de Zig en el navegador! 🌐💪\n¿Qué es WebAssembly? 🧐 WebAssembly es un formato de instrucción binaria diseñado como un objetivo portable para la compilación de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar código en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.","title":"WebAssembly y Zig: Comenzando 🕸️🚀"},{"content":"¡Hola, entusiastas de Zig! 👋 En nuestra publicación anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazón de la gestión de proyectos de Zig: el sistema de construcción de Zig. ¡Empecemos! 🎉\n¿Qué es el sistema de construcción de Zig? 🤔 El sistema de construcción de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos. Simplifica procesos de construcción complejos y proporciona una compilación cruzada sin interrupciones, permitiéndote apuntar a diferentes plataformas con facilidad.\nEmpezando con build.zig 🚀 Para aprovechar el sistema de construcción de Zig, necesitas crear un archivo build.zig en el directorio raíz de tu proyecto.\nEl conjunto de herramientas de Zig (toolchain) llama a la función build(b: *std.Build) void de build.zig. El parámetro bse utiliza para configurar y definir el proceso de construcción mediante pasos o instrucciones que no formen ciclos o bucles.\nPor ejemplo, podemos crear nuestro propio paso my-step:\n⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const my_step = b.step(\u0026#34;my-step\u0026#34;, \u0026#34;Este paso es mi paso\u0026#34;); _ = my_step; } Este paso aparecerá en la ayuda si ejecutamos zig build --help, y aunque no hace nada, hace mucha ilusión.\n$ zig build --help Usage: zig build [steps] [options] Steps: install (default) Copy build artifacts to prefix path uninstall Remove build artifacts from prefix path my-step Este paso es mi paso [...] Project-Specific Options: (none) [...] También podemos observar en la ayuda una sección Project-Specific Options, que por ahora aparece vacía.\nAñadiendo el primer paso 👣 Zig viene equipado con algunos pasos listos para usar. Uno de los más interesantes es addExecutable, que permite compilar un ejecutable o librería.\nSi añadimos este main.zig al directorio:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;Hola otra vez\\n\u0026#34;, .{}); } Y definimos build.zig como:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;my-executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); } Cuando ejecutemos el comando zig build se compilará nuestro ejecutable. Estas son las líneas principales:\nconst target = b.standardTargetOptions(.{}): Define las opciones de destino que estarán disponibles y cual será la de defecto, lo que permite al usuario seleccionar para qué plataforma se va a construir el código.\nconst optimize = b.standardOptimizeOption(.{}): Define las opciones de optimización estándar, lo que permite al usuario seleccionar el nivel de optimización para la compilación.\nconst exe = b.addExecutable(.): Añade un ejecutable al proceso de construcción. Los parámetros definen cómo se construirá el ejecutable, incluyendo el archivo fuente principal, las opciones de destino y las opciones de optimización.\nb.installArtifact(exe): Esta línea declara que el ejecutable creado en el paso anterior debe ser instalado en la ubicación estándar cuando se realiza el paso de instalación.\nSi volvemos a ejecutar zig build --help observaremos como ahora la sección Project-Specific Options muestra opciones para establecer la plataforma, características de la cpu y la optimización desde línea de comandos.\nProject-Specific Options: -Dtarget=[string] The CPU architecture, OS, and ABI to build for -Dcpu=[string] Target CPU features to add or subtract -Doptimize=[enum] Prioritize performance, safety, or binary size (-O flag) Supported Values: Debug ReleaseSafe ReleaseFast ReleaseSmall Al lanzar zig build se generarán dos directorios importantes:\nzig-cache: Este directorio contiene artefactos de construcción intermedios, como archivos de objeto, y es utilizado por el sistema de construcción de Zig para almacenar en caché los resultados de la construcción y acelerar las compilaciones posteriores. zig-out: Este directorio almacena la salida final de tu proceso de construcción, incluyendo ejecutables, bibliotecas y otros binarios. Compilación cruzada hecha fácil 🌉 Una de las características más poderosas del sistema de construcción de Zig es su capacidad para compilar de forma cruzada tus proyectos. Para ello simplemente proporciona la opción --target cuando ejecutes zig build:\nzig build -Dtarget=aarch64-linux-gnu Este comando compila tu proyecto para la plataforma objetivo especificada, manejando todas las complejidades por ti. 🎉\n$ file zig-out/bin/executable zig-out/bin/executable: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped Añadiendo más pasos 👣👣 Ahora que sabemos como funciona podemos añadir otros dos pasos, uno para ejecutar el programa y otro para lanzar los tests:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { // compilación const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); // ejecución const run_cmd = b.addRunArtifact(exe); if (b.args) |args| { run_cmd.addArgs(args); } run_cmd.step.dependOn(b.getInstallStep()); const run_step = b.step(\u0026#34;run\u0026#34;, \u0026#34;Run the app\u0026#34;); run_step.dependOn(\u0026amp;run_cmd.step); // tests const unit_tests = b.addTest(.{ .root_source_file = .{ .path = \u0026#34;main_test.zig\u0026#34; }, .target = target, .optimize = optimize, }); const run_unit_tests = b.addRunArtifact(unit_tests); const test_step = b.step(\u0026#34;test\u0026#34;, \u0026#34;Run unit tests\u0026#34;); test_step.dependOn(\u0026amp;run_unit_tests.step); } En este código podemos ver\nEl bloque if (b.args) |args| {...}: Añade cualquier argumento pasado al comando de ejecución.\nconst run_step = b.step(\u0026quot;run\u0026quot;, \u0026quot;Run the app\u0026quot;): Crea un paso de construcción que ejecuta el comando de ejecución.\nconst unit_tests = b.addTest(.) y const run_unit_tests = b.addRunArtifact(unit_tests): Crea un paso para las pruebas unitarias. Este paso construye el ejecutable de prueba pero no lo ejecuta.\nconst test_step = b.step(\u0026quot;test\u0026quot;, \u0026quot;Run unit tests\u0026quot;): Este paso ejecuta las pruebas unitarias.\nPara añadir los test añadimos el archivo main_test.zig:\nconst std = @import(\u0026#34;std\u0026#34;); test \u0026#34;simple test\u0026#34; { try std.testing.expect(addOne(41) == 42); } fn addOne(number: i32) i32 { return number + 1; } Para crear un caso de prueba en Zig, usa la palabra clave test, seguida de un nombre de prueba y un bloque de código.\nPara lanzar los test usamos el comando zig build test. Si todo va bien no deberíamos ver ningún error, el comando es realmente muy silencioso.\n¿Se puede más fácil? 😅 Crear un archivo build.zig puede ser un poco tedioso, más aun cuando todavía no dominamos el lenguaje. Pero no tienes por qué empezar desde cero. El comando zig init-exe te generará las carpetas y archivos necesarios para compilar, ejecutar y pasar los test de un proyecto de básico de ejemplo en el directorio donde te encuentres.\n¿Qué sigue? 🌟 ¡Eso es todo! Ahora tienes un sólido entendimiento del sistema de construcción de Zig y puedes usarlo para gestionar, construir y compilar de forma cruzada tus proyectos con facilidad. 💡\n¡Feliz codificación y nos vemos en la próxima publicación! 👩‍💻👨‍💻🚀\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/una-gu%C3%ADa-del-sistema-de-construcci%C3%B3n-en-zig/","summary":"¡Hola, entusiastas de Zig! 👋 En nuestra publicación anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazón de la gestión de proyectos de Zig: el sistema de construcción de Zig. ¡Empecemos! 🎉\n¿Qué es el sistema de construcción de Zig? 🤔 El sistema de construcción de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos.","title":"Una guía del sistema de construcción de Zig 🏗️"},{"content":"¡Saludos, entusiastas de Zig! 👋 Es el momento de configurar un entorno de desarrollo cómodo para mejorar tu experiencia de programación en Zig. En esta publicación, te guiaré para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo edición de código, ejecución y depuración. ¡Sumérgete en el tema! 🚀\nConfigurando Visual Studio Code para el desarrollo en Zig 🛠️ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:\nInstala Visual Studio Code: Si aún no lo has hecho, descarga e instala Visual Studio Code para tu plataforma (Linux, Windows o macOS).\nInstala la extensión de Zig: Abre el buscador rápido de VS Code (Ctrl+P), pega el siguiente comando y presiona enter.\next install ziglang.vscode-zig Configura los ajustes: Para configurar los ajustes de la extensión de Zig, abre el editor de Configuración haciendo clic en el ícono de engranaje en la esquina inferior izquierda de la ventana y selecciona \u0026ldquo;Configuración\u0026rdquo;. Busca \u0026ldquo;Zig\u0026rdquo; en la barra de búsqueda y actualiza los ajustes según sea necesario. Por ejemplo, es posible que desees establecer la ruta del compilador de Zig si no está en la ubicación predeterminada. ¡Listo! Ahora estás listo para desarrollar en Zig en VS Code. 🎉\nEjecutando y depurando código 🏃‍♀️💻 Para ejecutar y depurar código Zig en VS Code, sigue estos pasos:\nCrea un nuevo archivo Zig: Abre VS Code y crea un nuevo archivo con la extensión .zig, como main.zig.\nEscribe código Zig: Escribe un programa sencillo en Zig en tu nuevo archivo, como un programa \u0026ldquo;Hola, mundo\u0026rdquo;:\n⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { std.debug.print(\u0026#34;Hello, {s}!\\n\u0026#34;, .{\u0026#34;World\u0026#34;}); } Configura tasks.json: Para ejecutar tu código Zig, necesitas crear un archivo tasks.json en la carpeta .vscode de tu espacio de trabajo. Agrega la siguiente configuración al archivo: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;zig build-exe main.zig\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuración define tareas para Visual Studio Code. Las tareas se utilizan para automatizar el proceso de construcción, prueba y despliegue de tu aplicación. En este caso, estamos definiendo la tarea de compilación:\n\u0026quot;label\u0026quot;: \u0026quot;build\u0026quot; - Es el nombre que se le da a la tarea. En este caso, la tarea se llama \u0026ldquo;build\u0026rdquo;. \u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot; - Especifica que esta tarea se ejecutará en una shell o terminal. \u0026quot;command\u0026quot;: \u0026quot;zig build-exe main.zig\u0026quot; - Es el comando que se ejecutará cuando se inicie esta tarea. Este comando compilará el archivo main.zig en un ejecutable utilizando el compilador Zig. \u0026quot;group\u0026quot;: \u0026quot;build\u0026quot; - Esto agrupa la tarea en la categoría \u0026ldquo;build\u0026rdquo;. Las tareas se pueden agrupar para un fácil acceso y gestión en Visual Studio Code. Ejecuta tu código Zig: Presiona Ctrl+Shift+B (o Cmd+Shift+B en macOS) para ejecutar la tarea \u0026ldquo;build\u0026rdquo;, que compila tu código Zig. Salida:\n* Executing task: zig build-exe \u0026lt;...\u0026gt;/main.zig * Terminal will be reused by tasks, press any key to close it. Depuración: Para depurar tu código Zig, primero debes instalar las extensiones \u0026ldquo;Native Debug\u0026rdquo; de WebFreak y \u0026ldquo;CodeLLDB\u0026rdquo; de Vadim Chugunov. Presiona ctrl-p (cmd+p en macOS) y ejecuta los siguientes comandos:\next install webfreak.debug y\next install vadimcn.vscode-lldb Una vez instaladas, crea un archivo launch.json en la carpeta .vscode de tu espacio de trabajo con la siguiente configuración:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug Zig\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuración de lanzamiento se usa para definir cómo se debe depurar un proyecto. El campo configurations tiene una lista de diferentes configuraciones de depuración que puedes usar. Puedes cambiar entre estas configuraciones en el menú desplegable de depuración en la parte superior de VS Code. La configuración se define así:\nname: Es el nombre que aparece en el menú desplegable de depuración. En este caso, está configurado como \u0026ldquo;Debug Zig\u0026rdquo;, lo que indica que esta configuración es para depurar programas escritos en Zig. type: Define el depurador que se utilizará. En este caso, \u0026ldquo;lldb\u0026rdquo; indica que se utilizará el depurador LLDB de LLVM. request: Puede ser \u0026ldquo;launch\u0026rdquo; o \u0026ldquo;attach\u0026rdquo;. \u0026ldquo;launch\u0026rdquo; inicia el programa en el depurador, mientras que \u0026ldquo;attach\u0026rdquo; se conecta a un proceso ya en ejecución. En la configuración el valor es \u0026ldquo;launch\u0026rdquo;, por lo que el depurador iniciará el programa. program: Es el nombre del programa que se va a iniciar. En esta configuración, el valor es \u0026ldquo;main\u0026rdquo;, por lo que se espera un ejecutable llamado \u0026ldquo;main\u0026rdquo; en tu directorio de trabajo actual. args: Es una lista de argumentos que se pasarán al programa cuando se lance. En tu caso, esta lista está vacía, por lo que no se pasarán argumentos. cwd: Especifica el directorio de trabajo actual cuando se inicia el programa. \u0026ldquo;${workspaceFolder}\u0026rdquo; es una variable que se refiere al directorio raíz de tu espacio de trabajo actual en VS Code. preLaunchTask: Es el nombre de una tarea definida en tasks.json que se ejecutará antes de que se lance el programa. Este es solo un ejemplo de configuración de depuración. La configuración exacta puede variar según el lenguaje de programación y el entorno de desarrollo específicos que estés utilizando.\nDepura tu código Zig: Establece puntos de interrupción en tu código Zig haciendo clic en el margen izquierdo junto a los números de línea. Presiona F5 para iniciar la depuración. El depurador se detendrá en tus puntos de interrupción, lo que te permitirá inspeccionar variables, avanzar paso a paso en tu código y utilizar otras funciones de depuración. ¡Eso es todo! Ahora has configurado Visual Studio Code para el desarrollo en Zig, incluyendo la ejecución, asistencia y depuración de tu código. 🎉\n¿Qué más? 🌟 Con tu flamante entorno de desarrollo Zig, estás listo para explorar temas avanzados de Zig y crear proyectos asombrosos. ¡Mantente atento a más publicaciones en el blog sobre conceptos avanzados de Zig!\n¡Sigamos explorando el mundo de Zig juntos! 👩‍💻👨‍💻🎨\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/configura-visual-studio-code-para-programar-en-zig/","summary":"¡Saludos, entusiastas de Zig! 👋 Es el momento de configurar un entorno de desarrollo cómodo para mejorar tu experiencia de programación en Zig. En esta publicación, te guiaré para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo edición de código, ejecución y depuración. ¡Sumérgete en el tema! 🚀\nConfigurando Visual Studio Code para el desarrollo en Zig 🛠️ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:","title":"Configura Visual Studio Code para programar en Zig 🎨"},{"content":"¡Hola, entusiastas de Zig! 👋 En la publicación anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas más avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicación, te guiaré en la instalación de Zig en Linux, Windows y macOS. ¡Comencemos! 🚀\nInstalando Zig en Linux 🐧 ⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyéndolo desde el código fuente.\nPaquetes precompilados: Descarga el paquete apropiado para tu distribución de Linux desde la página oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nConstruir desde el código fuente: Si prefieres construir Zig desde el código fuente, sigue estos pasos:\nInstala las dependencias necesarias: build-essential, cmake y git. Clona el repositorio de Zig: git clone https://github.com/ziglang/zig.git Cambia al directorio clonado: cd zig Crea un directorio de construcción: mkdir build \u0026amp;\u0026amp; cd build Ejecuta CMake para configurar la construcción: cmake .. Construye Zig: make Agrega el binario zig a tu PATH. Una forma alternativa es usar snap: snap install --edge zig --classic\nInstalando Zig en Windows 💻 Para usuarios de Windows, puedes instalar Zig utilizando los paquetes precompilados o el administrador de paquetes Scoop.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la página oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nScoop: Si tienes Scoop instalado, puedes instalar Zig ejecutando: scoop install zig\nInstalando Zig en macOS 🍏 Para usuarios de macOS, puedes instalar Zig utilizando los paquetes precompilados, Homebrew o MacPorts.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la página oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nHomebrew: Si tienes Homebrew instalado, puedes instalar Zig ejecutando: brew install zig\nMacPorts: Si tienes MacPorts instalado, puedes instalar Zig ejecutando: sudo port install zig\n¡Listo! Ahora deberías tener Zig instalado en tu sistema Linux, Windows o macOS. 🎉\n¿Qué más? 🌟 Con Zig instalado, estás listo para explorar temas más avanzados y aprovechar todo el potencial de este emocionante lenguaje.\n¡Ánimo programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/instalando-zig-en-linux-windows-y-macos/","summary":"¡Hola, entusiastas de Zig! 👋 En la publicación anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas más avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicación, te guiaré en la instalación de Zig en Linux, Windows y macOS. ¡Comencemos! 🚀\nInstalando Zig en Linux 🐧 ⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyéndolo desde el código fuente.","title":"Instalando Zig en Linux, Windows y macOS 🌍"},{"content":"¡Bienvenido al emocionante mundo de Zig! 🚀 Si estás buscando un lenguaje de programación que combine eficiencia, seguridad y un enfoque en el rendimiento, ¡has llegado al lugar correcto!\n¿Por qué Zig? 🎯 Una de las primeras cosas que notarás al explorar Zig es su enfoque en la seguridad y la prevención de errores. El compilador de Zig es estricto y te ayudará a detectar problemas en tiempo de compilación antes de que se conviertan en pesadillas en tiempo de ejecución. Esto no solo te brinda una mayor confianza en la calidad de tu código, sino que también te enseña buenas prácticas para evitar errores comunes.\nPero Zig no se detiene solo en la seguridad. Si te apasiona la programación de alto rendimiento y quieres escribir código que aproveche al máximo los recursos del sistema, Zig es el lenguaje adecuado para ti. Su sintaxis limpia y elegante te permite escribir código eficiente y optimizado sin sacrificar la legibilidad.\nAdemás, aprender Zig te brinda la oportunidad de adentrarte en el mundo de la programación de bajo nivel. Con Zig, puedes acceder directamente a la memoria y tener un control preciso sobre los recursos del sistema. Esto es especialmente útil si estás interesado en desarrollar aplicaciones de sistemas embebidos, controladores de dispositivos o soluciones de bajo nivel.\nZig también es una excelente opción para aquellos que están aprendiendo a programar. A través de Zig, puedes adquirir una comprensión sólida de los conceptos fundamentales de la programación, como el control de flujo, las estructuras de datos y los algoritmos. Al mismo tiempo, ampliarás tu perspectiva sobre la programación y desarrollarás habilidades valiosas para el futuro.\nNo te voy a engañar: Zig a veces muerde 😬, pero eso es bueno. Es un lenguage en plena creación y evoluciona muy rápidamente con cambios incompatibles y bugs. Además su determinado enfoque en la seguridad te obliga a ser consciente de muchos aspectos que en otros lenguages simplemente se ignoran (el precio se paga después). Pero no temas programador, ¡todo eso te hará mas fuerte!.💪\n¡Hola, mundo! 👋 Como en cualquier lenguaje, el primer paso es escribir un clásico \u0026ldquo;Hola, mundo\u0026rdquo; en Zig para ver qué pinta tiene y qué sensaciones te produce:\n⚠️ ¡Atención, programador! Este post utiliza la versión 0.11.0-dev.3971 de Zig\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;¡Hola, mundo!\\n\u0026#34;,.{}); } Es muy poco código pero ya se pueden observar algunas características del lenguaje Zig:\nEnfoque en la seguridad: El uso de la declaración try para manejar errores de manera explícita demuestra la preocupación por la seguridad y la prevención de errores en Zig.\nSintaxis limpia y legible: La sintaxis del programa es clara y fácil de entender, lo que facilita la lectura y escritura de código en Zig.\nManejo explícito de recursos: Al obtener el escritor de salida estándar a través de getStdOut(), Zig enfatiza el manejo explícito de recursos, permitiendo un control más preciso y seguro.\nOrientación a bajo nivel: Zig permite acceder directamente a la memoria y proporciona un mayor control sobre los recursos del sistema, lo que es útil en situaciones de programación de bajo nivel.\nEnfoque en el rendimiento: Zig está diseñado para ofrecer un rendimiento excepcional, lo que se refleja en la eficiencia del programa \u0026ldquo;Hello, World\u0026rdquo;.\nEstas cualidades son solo una pequeña muestra de las fortalezas de Zig como lenguaje de programación. A medida que te adentres en Zig, descubrirás muchas más ventajas que te ayudarán a desarrollar software eficiente y confiable.\nOtro ejemplo, un poco más completo, tiene esta pinta:\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { // Prints to stderr (it\u0026#39;s a shortcut based on `std.io.getStdErr()`) std.debug.print(\u0026#34;All your {s} are belong to us.\\n\u0026#34;, .{\u0026#34;codebase\u0026#34;}); // stdout is for the actual output of your application, for example if you // are implementing gzip, then only the compressed bytes should be sent to // stdout, not any debugging messages. const stdout_file = std.io.getStdOut().writer(); var bw = std.io.bufferedWriter(stdout_file); const stdout = bw.writer(); try stdout.print(\u0026#34;Run `zig build test` to run the tests.\\n\u0026#34;, .{}); try bw.flush(); // don\u0026#39;t forget to flush! } test \u0026#34;simple test\u0026#34; { var list = std.ArrayList(i32).init(std.testing.allocator); defer list.deinit(); // try commenting this out and see if zig detects the memory leak! try list.append(42); try std.testing.expectEqual(@as(i32, 42), list.pop()); } Me gusta, ¿Cómo aprendo? 📚💡 La documentación oficial de Zig es un excelente punto de partida. Puedes acceder a ella en el sitio web oficial de Zig y encontrarás una guía detallada, ejemplos de código, tutoriales y una descripción completa de la biblioteca estándar. La documentación oficial es constantemente actualizada y es una fuente confiable para comprender la sintaxis, las características del lenguaje y las mejores prácticas. Recuerda, consulta siempre la documentación de la versión de Zig que estés utilizando, porque puede variar mucho de una a otra.\nEl repositorio oficial de Zig en GitHub es una fuente invaluable de código fuente abierto en Zig. Puedes explorar proyectos de la comunidad, estudiar el código existente y aprender de ejemplos prácticos. También puedes contribuir a proyectos existentes o incluso iniciar tus propios proyectos en Zig.\nAdemás de GitHub, el subreddit de Zig y el canal de Discord oficial de Zig son excelentes lugares para conectarte con otros programadores de Zig, hacer preguntas, compartir conocimientos y obtener ayuda. Estos espacios de la comunidad están llenos de personas amigables y conocedoras que están dispuestas a ayudarte en tu viaje de aprendizaje en Zig.\nRecuerda que la práctica es fundamental para dominar cualquier lenguaje de programación. A medida que adquieras conocimientos, te recomiendo implementar proyectos pequeños y desafiantes por tu cuenta. Esto te permitirá aplicar lo que has aprendido, experimentar con difer\nY por supuesto ¡sigue este blog!. Te llevaré a un emocionante viaje a través del mundo de Zig. Compartiré tutoriales, consejos útiles, trucos y experiencias personales mientras exploramos juntos las maravillas y desafíos de este increíble lenguaje de programación. Desde los conceptos básicos hasta técnicas avanzadas, encontrarás contenido fresco y relevante para mejorar tus habilidades en Zig.\nAhora empieza todo ¡No te pierdas ninguno de los nuevos artículos de \u0026ldquo;Zig-zagueando\u0026rdquo;! Puedes suscribirte al blog mediante el clásico y eficiente RSS 📰 para recibir notificaciones cada vez que publique una nueva entrada. Además, te invito a participar en los comentarios, compartir tus propias experiencias y hacer preguntas sobre cualquier tema relacionado con Zig.\n¡Prepárate para disfrutar de un blog lleno de conocimientos, diversión y aventuras en Zig! ¡Nos vemos, valiente programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-un-lenguaje-de-programaci%C3%B3n-simple-y-potente/","summary":"¡Bienvenido al emocionante mundo de Zig! 🚀 Si estás buscando un lenguaje de programación que combine eficiencia, seguridad y un enfoque en el rendimiento, ¡has llegado al lugar correcto!\n¿Por qué Zig? 🎯 Una de las primeras cosas que notarás al explorar Zig es su enfoque en la seguridad y la prevención de errores. El compilador de Zig es estricto y te ayudará a detectar problemas en tiempo de compilación antes de que se conviertan en pesadillas en tiempo de ejecución.","title":"Zig: Un lenguaje de programación simple y potente 🚀"}]